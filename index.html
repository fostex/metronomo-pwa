<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metronomo Avanzato</title>
    <!-- Carica Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Stili personalizzati per la PWA */
        :root {
            /* Tema Scuro */
            --primary-color: #3b82f6; /* Blu di Tailwind 500 */
            --accent-color: #f97316; /* Arancione di Tailwind 500 */
            --bg-color: #1f2937; /* Grigio scuro/Nero */
            --card-color: #2d3748; /* NUOVO: Grigio/Blu scuro per il riquadro */
            --text-color: #f9fafb; /* Testo molto chiaro */
            --input-bg-color: #4b5563; /* Sfondo input scuro */
            --input-border-color: #6b7280;
            --tempo-text-color: #93c5fd; /* Blu chiaro/Viola come da foto */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            color: var(--text-color);
        }

        .metronome-card {
            width: 100%;
            max-width: 500px;
            background-color: var(--card-color);
            border-radius: 1rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5), 0 10px 10px -5px rgba(0, 0, 0, 0.4);
            padding: 30px;
            transition: all 0.3s ease-in-out;
        }

        /* Classe per il contenitore delle etichette e input per l'allineamento verticale */
        .input-group-aligned {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            height: 100%;
        }

        .control-label {
            font-size: 0.875rem; /* text-sm */
            font-weight: 500; /* font-medium */
            color: var(--text-color);
            margin-bottom: 4px; /* Spazio tra label e input */
        }

        /* Rimuove le frecce di default dagli input di tipo number */
        input[type="number"] {
            appearance: none;
            -moz-appearance: textfield;
            background-color: var(--input-bg-color);
            border-color: var(--input-border-color);
            color: var(--text-color);
            height: 3.5rem; /* h-14: Altezza input uniforme */
            border: 1px solid var(--input-border-color);
            border-radius: 0.5rem;
            padding: 0.5rem 0.75rem;
            text-align: center; 
        }
        
        input[type="number"]::-webkit-inner-spin-button, 
        input[type="number"]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }

        /* Stile personalizzato per lo slider di input[range] */
        input[type=range] {
          -webkit-appearance: none;
          width: 100%;
          background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
          -webkit-appearance: none;
          height: 24px;
          width: 24px;
          border-radius: 50%;
          background: var(--primary-color);
          cursor: pointer;
          margin-top: -10px;
          box-shadow: 0 0 5px rgba(0, 0, 0, 0.4);
        }
        input[type=range]::-webkit-slider-runnable-track {
          width: 100%;
          height: 4px;
          cursor: pointer;
          background: #4b5563;
          border-radius: 2px;
        }

        /* Pallini Battito Visualizzazione */
        .beat-dot {
            width: 48px; 
            height: 48px;
            background-color: #4b5563;
            border-radius: 50%;
            transition: background-color 0.1s, transform 0.1s;
        }
        
        .beat-dot.scale-120 { 
            transform: scale(1.15); 
        }

        .beat-dot.strong {
            background-color: var(--accent-color);
            box-shadow: 0 0 20px var(--accent-color);
        }

        .beat-dot.weak {
            background-color: var(--primary-color);
            box-shadow: 0 0 20px var(--primary-color);
        }
        
        /* Stile per l'indicatore dinamico di tempo */
        .dynamic-tempo-text {
            height: 24px;
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--tempo-text-color);
            margin-top: 24px;
            margin-bottom: 4px;
        }
        
        /* Stile specifico per il bottone Tap Tempo */
        .tap-tempo-btn {
            background-color: #f97316; /* Arancione (Accent) */
            box-shadow: 0 4px 15px rgba(249, 115, 22, 0.4); /* Ombra arancione */
        }
        .tap-tempo-btn:hover {
            background-color: #ea580c; /* Arancione più scuro al passaggio del mouse */
        }
        
        /* --------------------------------- */
        /* Stili per i pulsanti stepper VERTICALI */
        /* --------------------------------- */
        .stepper-btn-vertical {
            background-color: var(--input-bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            line-height: 1;
            transition: background-color 0.1s;
        }
        .stepper-btn-vertical:hover {
            background-color: #374151;
        }
        
        /* Contenitore Stepper */
        .stepper-vertical-group {
            display: flex;
            align-items: stretch; /* Allunga l'input all'altezza del contenitore */
            border: 1px solid var(--input-border-color);
            border-radius: 0.5rem;
            overflow: hidden;
            height: 3.5rem; /* Altezza uniforme h-14 */
        }
        
        /* Input centrale nel gruppo stepper */
        .stepper-vertical-group input[type="number"] {
            border: none;
            border-radius: 0;
            flex-grow: 1; /* Permette all'input di occupare lo spazio centrale */
            padding: 0.5rem 0.5rem;
            font-size: 1.5rem;
        }

        /* Controlli verticali per + e - */
        .stepper-controls-vertical {
            display: flex;
            flex-direction: column;
            width: 38px; /* Larghezza fissa per i controlli */
            height: 100%;
        }
        
        /* Stili specifici per i pulsanti verticali */
        .stepper-btn-vertical.top {
            flex-grow: 1;
            border-bottom: 1px solid var(--input-border-color);
            border-left: 1px solid var(--input-border-color);
            padding: 0;
            font-size: 1.125rem; /* text-lg */
        }
        .stepper-btn-vertical.bottom {
            flex-grow: 1;
            border-left: 1px solid var(--input-border-color);
            padding: 0;
            font-size: 1.125rem; /* text-lg */
        }
        
        /* Stili per il Toggle */
        .toggle-label {
            background-color: #6b7280 !important;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: var(--primary-color) !important;
        }
        .toggle-checkbox { opacity: 0; width: 0; height: 0; }
        .toggle-label {
            position: relative; display: block; height: 1.5rem; width: 2.5rem; border-radius: 9999px; cursor: pointer; transition: background-color 0.2s ease;
        }
        .toggle-label:before {
            content: ''; position: absolute; top: 2px; left: 2px; height: 1.25rem; width: 1.25rem; border-radius: 50%; background: white; transition: transform 0.2s ease;
        }
        .toggle-checkbox:checked + .toggle-label { background-color: var(--primary-color); }
        .toggle-checkbox:checked + .toggle-label:before { transform: translateX(1rem); }
    </style>
</head>
<body>

    <div id="app" class="metronome-card">
        <h1 class="text-3xl font-bold mb-6 text-center text-gray-100">Metronomo</h1>
        
        <!-- Timer Countdown Display -->
        <div id="timerDisplay" class="text-center text-3xl font-extrabold mb-4 text-red-400 hidden">
            00:00
        </div>
        
        <!-- Indicatore del BPM Corrente e del Tempo -->
        <div class="text-center mb-8">
            <p class="text-6xl font-extrabold" id="displayBPM">120</p>
            <p class="text-sm text-gray-300 mt-1" id="currentBPMText">BPM Corrente</p>
        </div>

        <!-- Indicatori del Battito (Visualizzazione in riproduzione) -->
        <div id="beatIndicators" class="flex justify-center space-x-4 mb-4" style="min-height: 48px;">
            <!-- I pallini verranno generati qui -->
        </div>
        
        <!-- Indicatore del Tempo Dinamico -->
        <div class="text-center dynamic-tempo-text">
            <span id="tempoIndicatorText" class="tracking-widest">MODERATO (109-120)</span>
        </div>


        <!-- Slider per la regolazione fine del BPM -->
        <div class="mb-8 px-1 relative">
            <input type="range" id="bpmSlider" min="40" max="300" value="120" 
                   class="w-full transition duration-150">
        </div>

        <!-- Controlli Principali (Input) -->
        <div class="grid grid-cols-2 gap-4 mb-6">
            
            <!-- Campo BPM con Stepper Verticale -->
            <div class="input-group-aligned">
                <label for="bpm" class="control-label">BPM</label>
                <div class="stepper-vertical-group w-full">
                    <input type="number" id="bpm" value="120" min="40" max="300" data-step="5">
                    <div class="stepper-controls-vertical">
                        <button type="button" onclick="changeValue('bpm', 5)" 
                                class="stepper-btn-vertical top">+</button>
                        <button type="button" onclick="changeValue('bpm', -5)" 
                                class="stepper-btn-vertical bottom">-</button>
                    </div>
                </div>
            </div>

            <!-- Selettore Battiti per Misura (Dropdown) -->
            <div class="input-group-aligned relative">
                <label for="timeSignatureSelect" class="control-label">Battiti per Misura</label>
                <select id="timeSignatureSelect" class="w-full appearance-none pr-8 text-center bg-gray-600 h-14 rounded-lg border border-gray-500 text-white">
                    <option value="2">2/4</option>
                    <option value="3">3/4</option>
                    <option value="4" selected>4/4</option>
                    <option value="5">5/4</option>
                    <option value="6">6/8</option>
                    <option value="7">7/4</option>
                    <option value="8">8/4</option>
                    <option value="9">9/8</option>
                    <option value="12">12/8</option>
                </select>
                <!-- Aggiunge l'icona freccia a destra -->
                <div class="absolute inset-y-0 right-0 top-[34px] flex items-center px-2 pointer-events-none">
                    <svg class="w-4 h-4 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
            </div>
        </div>
        
        <!-- Pulsanti START/STOP e TAP TEMPO affiancati (Layout 8/12 e 4/12 per diverse larghezze e py-5 per altezza aumentata) -->
        <div class="grid grid-cols-12 gap-4 mb-6">
            <!-- Pulsante START/STOP (col-span-8 per essere più grande) -->
            <button id="startButton" class="col-span-8 w-full text-white font-bold py-5 px-4 rounded-xl 
                                             bg-green-500 hover:bg-green-600 active:bg-green-700 
                                             transition duration-150 shadow-lg shadow-green-500/50">
                INIZIA
            </button>
            
            <!-- Pulsante TAP TEMPO (col-span-4 per essere più corto) -->
            <button id="tapTempoButton" class="col-span-4 w-full text-white font-bold py-5 px-4 rounded-xl 
                                                tap-tempo-btn 
                                                transition duration-150 shadow-lg">
                TAP TEMPO
            </button>
        </div>


        <!-- Toggle per il Timer -->
        <div class="mb-4 flex items-center justify-between p-3 bg-gray-600 rounded-lg shadow-inner">
            <label for="timerToggle" class="text-sm font-semibold text-gray-100">Attiva Timer</label>
            <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                <input type="checkbox" name="timerToggle" id="timerToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" />
                <label for="timerToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
            </div>
        </div>

        <!-- Controlli Timer con Stepper Verticale (Visibilità Condizionale) -->
        <div id="timerControls" class="grid grid-cols-2 gap-4 mb-6 hidden">
            <!-- Minuti con Stepper Verticale -->
            <div class="input-group-aligned">
                <label for="timerMinutes" class="control-label">Minuti</label>
                <div class="stepper-vertical-group w-full">
                    <!-- Aggiunto data-step="1" per la logica JS, anche se già gestito dal changeValue -->
                    <input type="number" id="timerMinutes" value="5" min="0" max="99" data-step="1">
                    <div class="stepper-controls-vertical">
                        <button type="button" onclick="changeValue('timerMinutes', 1)" 
                                class="stepper-btn-vertical top">+</button>
                        <button type="button" onclick="changeValue('timerMinutes', -1)" 
                                class="stepper-btn-vertical bottom">-</button>
                    </div>
                </div>
            </div>
            
            <!-- Secondi con Stepper Verticale -->
            <div class="input-group-aligned">
                <label for="timerSeconds" class="control-label">Secondi</label>
                <div class="stepper-vertical-group w-full">
                    <!-- Aggiunto data-step="1" per la logica JS, anche se già gestito dal changeValue -->
                    <input type="number" id="timerSeconds" value="0" min="0" max="59" data-step="1">
                    <div class="stepper-controls-vertical">
                        <button type="button" onclick="changeValue('timerSeconds', 1)" 
                                class="stepper-btn-vertical top">+</button>
                        <button type="button" onclick="changeValue('timerSeconds', -1)" 
                                class="stepper-btn-vertical bottom">-</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Toggle per l'Accelerazione Progressiva -->
        <div class="mb-4 flex items-center justify-between p-3 bg-gray-600 rounded-lg shadow-inner">
            <label for="progressiveAccelerationToggle" class="text-sm font-semibold text-gray-100">Accelerazione Progressiva</label>
            <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                <input type="checkbox" name="toggle" id="progressiveAccelerationToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" />
                <label for="progressiveAccelerationToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
            </div>
        </div>

        <!-- Controlli di Accelerazione con Stepper Verticale (Visibilità Condizionale e Allineati) -->
        <div id="accelerationControls" class="grid grid-cols-2 gap-4 mb-8 hidden">
            
            <!-- Misure per accelerazione con Stepper Verticale -->
            <div class="input-group-aligned">
                <label for="measuresForAcceleration" class="control-label">Misure per accel.</label>
                <div class="stepper-vertical-group w-full">
                    <!-- Aggiunto data-step="1" per la logica JS, anche se già gestito dal changeValue -->
                    <input type="number" id="measuresForAcceleration" value="4" min="1" data-step="1">
                    <div class="stepper-controls-vertical">
                        <button type="button" onclick="changeValue('measuresForAcceleration', 1)" 
                                class="stepper-btn-vertical top">+</button>
                        <button type="button" onclick="changeValue('measuresForAcceleration', -1)" 
                                class="stepper-btn-vertical bottom">-</button>
                    </div>
                </div>
            </div>

            <!-- Aumento BPM con Stepper Verticale -->
            <div class="input-group-aligned">
                <label for="bpmIncrease" class="control-label">Aumento BPM</label>
                <div class="stepper-vertical-group w-full">
                    <!-- Aggiunto data-step="1" per la logica JS, anche se già gestito dal changeValue -->
                    <input type="number" id="bpmIncrease" value="5" min="1" data-step="1">
                    <div class="stepper-controls-vertical">
                        <button type="button" onclick="changeValue('bpmIncrease', 1)" 
                                class="stepper-btn-vertical top">+</button>
                        <button type="button" onclick="changeValue('bpmIncrease', -1)" 
                                class="stepper-btn-vertical bottom">-</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Messaggio di Stato (per feedback) -->
        <div id="statusMessage" class="mt-4 p-3 bg-blue-800 border border-blue-600 text-blue-100 rounded-lg text-sm hidden">
            Stato: Pronto
        </div>
    </div>

    <script>
        // Variabili globali per l'audio e il timer
        let audioContext;
        let timerWorker;
        let isRunning = false;
        let currentBPM = 120;
        let currentBeat = 0;
        let currentMeasure = 0;
        
        // Configurazioni
        let lookahead = 25.0; // Guarda in avanti di 25 ms
        let scheduleAheadTime = 0.1; // Pianifica 100 ms in anticipo

        // Stato Tap Tempo
        let tapTimes = [];
        const TAP_MAX_DIFF = 2000;
        const TAP_MIN_COUNT = 3;

        // Stato dell'App
        let nextNoteTime = 0.0;
        let beatsPerMeasure = 4; // Default iniziale
        let progressiveAcceleration = false;
        let measuresForAcceleration = 4;
        let bpmIncrease = 5;
        let initialBPM = 120;
        
        // Stato Timer
        let timerWorkerId = null; // ID per l'intervallo di countdown
        let timerEnabled = false;
        let remainingTimeSeconds = 0;
        
        // Elementi DOM
        const startButton = document.getElementById('startButton');
        const tapTempoButton = document.getElementById('tapTempoButton');
        const displayBPM = document.getElementById('displayBPM');
        const beatIndicatorsDiv = document.getElementById('beatIndicators');
        const tempoIndicatorText = document.getElementById('tempoIndicatorText');
        const bpmInput = document.getElementById('bpm');
        const bpmSlider = document.getElementById('bpmSlider');
        const accelerationControls = document.getElementById('accelerationControls');
        const progressiveAccelerationToggle = document.getElementById('progressiveAccelerationToggle');
        const measuresForAccelerationInput = document.getElementById('measuresForAcceleration');
        const bpmIncreaseInput = document.getElementById('bpmIncrease');
        const statusMessage = document.getElementById('statusMessage');
        const timeSignatureSelect = document.getElementById('timeSignatureSelect'); // Select Battiti
        const timerToggle = document.getElementById('timerToggle'); 
        const timerControls = document.getElementById('timerControls'); 
        const timerMinutesInput = document.getElementById('timerMinutes');
        const timerSecondsInput = document.getElementById('timerSeconds');
        const timerDisplay = document.getElementById('timerDisplay');
        
        // Definizioni dei tempi musicali
        const tempoMap = [
            { minBPM: 40, maxBPM: 60, name: "Largo" },
            { minBPM: 61, maxBPM: 76, name: "Adagio" },
            { minBPM: 77, maxBPM: 108, name: "Andante" },
            { minBPM: 109, maxBPM: 120, name: "Moderato" },
            { minBPM: 121, maxBPM: 168, name: "Allegro" },
            { minBPM: 169, maxBPM: 200, name: "Presto" },
            { minBPM: 201, maxBPM: 300, name: "Prestissimo" }
        ];

        // --- Funzioni di Controllo Stepper ---

        /**
         * Incrementa o decrementa il valore di un input numerico.
         * @param {string} elementId L'ID dell'elemento input.
         * @param {number} step Il passo di incremento/decremento.
         */
        function changeValue(elementId, step) {
            const input = document.getElementById(elementId);
            if (!input) return;

            let currentValue = parseInt(input.value) || 0;
            let newValue = currentValue + step;

            // Controlli Min/Max
            const min = parseInt(input.min) || -Infinity;
            const max = parseInt(input.max) || Infinity;

            // Logica specifica per i secondi (roll over 0-59)
            if (elementId === 'timerSeconds') {
                if (newValue < 0) newValue = 59; // 0 - 1 = 59
                if (newValue > 59) newValue = 0; // 59 + 1 = 0
            } else {
                // Per tutti gli altri campi (BPM, Minuti, Accelerazione)
                if (newValue < min) newValue = min;
                if (newValue > max) newValue = max;
            }

            input.value = newValue;
            
            // Simula l'evento input per aggiornare la visualizzazione
            input.dispatchEvent(new Event('input', { bubbles: true }));
        }
        
        // Espone la funzione globalmente per gli handler onClick nell'HTML
        window.changeValue = changeValue;

        // --- Funzioni Audio (Invariate) ---

        /**
         * Crea un suono a onda quadra per un singolo battito.
         */
        function playBeat(time, frequency, duration) {
            if (!audioContext) return;

            const osc = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            osc.connect(gainNode);
            gainNode.connect(audioContext.destination);

            osc.type = "square";
            osc.frequency.setValueAtTime(frequency, time);

            gainNode.gain.setValueAtTime(0, time);
            gainNode.gain.linearRampToValueAtTime(0.5, time + 0.001);
            gainNode.gain.exponentialRampToValueAtTime(0.001, time + duration);

            osc.start(time);
            osc.stop(time + duration);
        }

        /**
         * Pianifica la prossima nota.
         */
        function scheduleNote() {
            let noteLength = 60.0 / currentBPM;
            let noteFrequency = 440;
            let noteDuration = 0.05;

            currentBeat = (currentBeat + 1) % beatsPerMeasure;
            
            if (currentBeat === 0) {
                noteFrequency = 880; // Battito forte
                currentMeasure++;
            } else {
                noteFrequency = 440; // Battito debole
            }

            playBeat(nextNoteTime, noteFrequency, noteDuration);
            
            postMessageToMainThread({ type: 'updateUI', beat: currentBeat, bpm: currentBPM });
            
            nextNoteTime += noteLength;

            // Logica di accelerazione
            if (progressiveAcceleration && currentBeat === 0) {
                if (currentMeasure % measuresForAcceleration === 0 && currentMeasure > 0) {
                    currentBPM += bpmIncrease;
                }
            }
        }

        /**
         * Funzione principale di pianificazione del metronomo.
         */
        function scheduler() {
            while (nextNoteTime < audioContext.currentTime + scheduleAheadTime) {
                scheduleNote();
            }
        }

        // --- Gestione UI e Worker Thread ---

        /**
         * Invia un messaggio al thread principale per aggiornare la UI.
         */
        function postMessageToMainThread(data) {
            if (typeof window !== 'undefined' && window.requestAnimationFrame) {
                window.requestAnimationFrame(() => handleWorkerMessage(data));
            }
        }
        
        /**
         * Gestisce i messaggi dal Worker (o chiamati direttamente per l'UI update).
         */
        function handleWorkerMessage(e) {
            if (e.type === 'updateUI') {
                updateBeatIndicators(e.beat);
                if (e.bpm !== parseInt(displayBPM.textContent)) {
                    updateBPMDisplay(e.bpm);
                }
            }
        }
        
        /**
         * Aggiorna tutti gli indicatori BPM e il testo di tempo.
         */
        function updateBPMDisplay(bpmValue) {
            const newBPM = parseInt(bpmValue);
            if (newBPM < 40 || newBPM > 300) return;
            
            displayBPM.textContent = newBPM;
            bpmInput.value = newBPM;
            bpmSlider.value = newBPM;
            
            // Aggiorna l'indicatore di tempo dinamico
            tempoIndicatorText.textContent = getTempoName(newBPM);
        }

        /**
         * Determina il nome del tempo in base al BPM.
         */
        function getTempoName(bpm) {
            let tempoEntry = tempoMap.find(entry => bpm >= entry.minBPM && bpm <= entry.maxBPM);
            
            if (tempoEntry) {
                const name = tempoEntry.name;
                const minBPM = tempoEntry.minBPM;
                const maxBPM = tempoEntry.maxBPM;
                
                const formattedName = name.charAt(0) + name.slice(1).toLowerCase();
                return `${formattedName} (${minBPM}-${maxBPM})`;
            }
            
            if (bpm < tempoMap[0].minBPM) {
                const name = tempoMap[0].name;
                return `${name.charAt(0) + name.slice(1).toLowerCase()} (<${tempoMap[0].minBPM})`;
            }
             if (bpm > tempoMap[tempoMap.length - 1].maxBPM) {
                const name = tempoMap[tempoMap.length - 1].name;
                return `${name.charAt(0) + name.slice(1).toLowerCase()} (>${tempoMap[tempoMap.length - 1].maxBPM})`;
            }
            
            return "Tempo Sconosciuto";
        }


        // --- Funzioni UI e Logica ---

        /**
         * Genera i pallini per la visualizzazione dei battiti in riproduzione.
         */
        function setupBeatIndicators() {
            // Aggiorna beatsPerMeasure dal select
            beatsPerMeasure = parseInt(timeSignatureSelect.value) || 4;
            
            beatIndicatorsDiv.innerHTML = '';
            for (let i = 0; i < beatsPerMeasure; i++) {
                const dot = document.createElement('div');
                dot.classList.add('beat-dot', 'transform', 'scale-100'); 
                dot.id = `dot-${i}`;
                beatIndicatorsDiv.appendChild(dot);
            }
        }

        /**
         * Aggiorna l'animazione dei pallini in riproduzione.
         */
        function updateBeatIndicators(beat) {
            const dots = beatIndicatorsDiv.querySelectorAll('.beat-dot');
            dots.forEach(dot => {
                dot.classList.remove('strong', 'weak', 'scale-120');
                dot.classList.add('scale-100');
            });

            const currentDot = document.getElementById(`dot-${beat}`);
            
            if (currentDot) {
                if (beat === 0) {
                    currentDot.classList.add('strong', 'scale-120');
                } else {
                    currentDot.classList.add('weak', 'scale-120');
                }
            }
        }
        
        /**
         * Aggiorna lo stato di visibilità dei controlli di accelerazione.
         */
        function updateAccelerationControlsVisibility() {
            progressiveAcceleration = progressiveAccelerationToggle.checked;
            if (progressiveAcceleration) {
                accelerationControls.classList.remove('hidden');
            } else {
                accelerationControls.classList.add('hidden');
            }
        }
        
        /**
         * Gestisce il countdown del timer.
         */
        function countdownTimer() {
            remainingTimeSeconds--;
            
            if (remainingTimeSeconds <= 0) {
                clearInterval(timerWorkerId);
                timerWorkerId = null;
                remainingTimeSeconds = 0;
                updateTimerDisplay();
                stopMetronome(true); // Indica che è stato fermato dal timer
                return;
            }
            
            updateTimerDisplay();
        }
        
        /**
         * Aggiorna il display del timer con il formato MM:SS.
         */
        function updateTimerDisplay() {
            const min = Math.floor(remainingTimeSeconds / 60);
            const sec = remainingTimeSeconds % 60;
            timerDisplay.textContent = 
                `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
        }

        /**
         * Gestisce l'evento click del pulsante START/STOP.
         */
        function toggleMetronome() {
            if (isRunning) {
                stopMetronome(false);
            } else {
                startMetronome();
            }
        }

        /**
         * Avvia il metronomo.
         */
        function startMetronome() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            // Aggiorna le configurazioni dall'UI
            initialBPM = parseInt(bpmInput.value) || 120;
            currentBPM = initialBPM;
            progressiveAcceleration = progressiveAccelerationToggle.checked;
            measuresForAcceleration = parseInt(measuresForAccelerationInput.value) || 4;
            bpmIncrease = parseInt(bpmIncreaseInput.value) || 5;
            timerEnabled = timerToggle.checked;
            beatsPerMeasure = parseInt(timeSignatureSelect.value) || 4; // Legge il valore aggiornato

            // Configurazione e avvio del Timer (se abilitato)
            if (timerEnabled) {
                const minutes = parseInt(timerMinutesInput.value) || 0;
                const seconds = parseInt(timerSecondsInput.value) || 0;
                const totalDurationSeconds = minutes * 60 + seconds;
                remainingTimeSeconds = totalDurationSeconds;

                if (remainingTimeSeconds > 0) {
                    updateTimerDisplay();
                    timerDisplay.classList.remove('hidden');
                    timerWorkerId = setInterval(countdownTimer, 1000); // Avvia il countdown sul thread principale
                } else {
                    timerDisplay.classList.add('hidden');
                    // Timer abilitato ma durata zero, avvisa e non avvia il countdown
                    statusMessage.textContent = "Timer abilitato ma durata zero. Avvio senza timer.";
                    statusMessage.classList.remove('hidden');
                }
            } else {
                timerDisplay.classList.add('hidden');
            }


            // Reset stato metronomo
            currentBeat = beatsPerMeasure - 1;
            currentMeasure = 0;
            nextNoteTime = audioContext.currentTime;

            setupBeatIndicators();
            updateBeatIndicators(0);
            updateBPMDisplay(currentBPM);
            
            // Avvia il Worker per il timer metronomo
            timerWorker = new Worker(URL.createObjectURL(new Blob([`
                let timerID = null;
                let interval = ${lookahead};

                self.onmessage = function(e) {
                    if (e.data === "start") {
                        timerID = setInterval(function() {
                            postMessage("tick");
                        }, interval);
                    } else if (e.data === "stop") {
                        clearInterval(timerID);
                        timerID = null;
                    }
                };
            `], { type: 'application/javascript' })));

            timerWorker.onmessage = function(e) {
                if (e.data === "tick") {
                    scheduler();
                }
            };
            
            timerWorker.postMessage("start");
            
            isRunning = true;
            startButton.textContent = "FERMA";
            startButton.classList.remove('bg-green-500', 'hover:bg-green-600', 'shadow-green-500/50');
            startButton.classList.add('bg-red-500', 'hover:bg-red-600', 'shadow-red-500/50');
            statusMessage.textContent = "Stato: In esecuzione";
            statusMessage.classList.remove('hidden');
        }

        /**
         * Ferma il metronomo.
         */
        function stopMetronome(wasTimer = false) {
            isRunning = false;

            if (timerWorker) {
                timerWorker.postMessage("stop");
                timerWorker.terminate();
                timerWorker = null;
            }
            
            // Ferma e resetta il timer countdown se era in esecuzione
            if (timerWorkerId) {
                clearInterval(timerWorkerId);
                timerWorkerId = null;
            }
            remainingTimeSeconds = 0;
            updateTimerDisplay(); // Aggiorna il display a 00:00

            // Reset UI
            startButton.textContent = "INIZIA";
            startButton.classList.remove('bg-red-500', 'hover:bg-red-600', 'shadow-red-500/50');
            startButton.classList.add('bg-green-500', 'hover:bg-green-600', 'shadow-green-500/50');
            updateBPMDisplay(initialBPM);
            
            if (wasTimer) {
                statusMessage.textContent = "Stato: Fine del tempo! Metronomo fermato automaticamente.";
            } else {
                statusMessage.textContent = "Stato: Fermato. BPM Iniziale: " + initialBPM;
            }
            
            // Rimuove l'evidenziazione e resetta i pallini
            const dots = beatIndicatorsDiv.querySelectorAll('.beat-dot');
            dots.forEach(dot => {
                dot.classList.remove('strong', 'weak', 'scale-120');
                dot.classList.add('scale-100');
            });
            
            currentBPM = initialBPM;
        }

        /**
         * Calcola il BPM dal Tap Tempo e aggiorna la UI.
         */
        function handleTapTempo() {
            if (isRunning) {
                stopMetronome(false);
            }

            const now = Date.now();

            if (tapTimes.length > 0 && now - tapTimes[tapTimes.length - 1] > TAP_MAX_DIFF) {
                tapTimes = [];
            }

            tapTimes.push(now);

            if (tapTimes.length > 5) {
                tapTimes.shift();
            }

            if (tapTimes.length >= TAP_MIN_COUNT) {
                let intervals = [];
                for (let i = 1; i < tapTimes.length; i++) {
                    intervals.push(tapTimes[i] - tapTimes[i-1]);
                }

                const avgInterval = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length;
                let calculatedBPM = Math.round(60000 / avgInterval);

                if (calculatedBPM < 40) calculatedBPM = 40;
                if (calculatedBPM > 300) calculatedBPM = 300;

                updateBPMDisplay(calculatedBPM);
                initialBPM = calculatedBPM;
                
                statusMessage.textContent = `Tap Tempo: ${calculatedBPM} BPM calcolato.`;

            } else {
                statusMessage.textContent = `Tap Tempo: Tocca ancora ${TAP_MIN_COUNT - tapTimes.length} volte.`;
            }
            statusMessage.classList.remove('hidden');
        }


        // --- Gestione Eventi e Inizializzazione ---

        document.addEventListener('DOMContentLoaded', () => {
            
            // Inizializza gli elementi UI
            setupBeatIndicators();
            updateAccelerationControlsVisibility();
            updateBPMDisplay(bpmInput.value);

            // Listener per il pulsante START/STOP
            startButton.addEventListener('click', toggleMetronome);
            
            // Listener per Tap Tempo
            tapTempoButton.addEventListener('click', handleTapTempo);

            // Listener per la visibilità condizionale (Accelerazione)
            progressiveAccelerationToggle.addEventListener('change', updateAccelerationControlsVisibility);
            
            // Listener per il toggle del Timer
            timerToggle.addEventListener('change', () => {
                timerEnabled = timerToggle.checked;
                if (timerEnabled) {
                    timerControls.classList.remove('hidden');
                } else {
                    timerControls.classList.add('hidden');
                }
            });
            
            // Listener per la selezione dei Battiti (Time Signature)
            timeSignatureSelect.addEventListener('change', () => {
                if (isRunning) {
                    statusMessage.textContent = "Ferma il metronomo per cambiare i battiti per misura.";
                    statusMessage.classList.remove('hidden');
                    // Riporta il select al valore corrente se in esecuzione
                    timeSignatureSelect.value = beatsPerMeasure.toString();
                    return;
                }
                beatsPerMeasure = parseInt(timeSignatureSelect.value) || 4;
                setupBeatIndicators(); // Ridisegna i pallini
            });


            // Listener per BPM Input, Slider, e Stepper (grazie a dispatchEvent('input'))
            const bpmChangeHandler = (event) => {
                const newBPM = parseInt(event.target.value) || 120;
                // Assicura che il valore rimanga nei limiti
                const min = parseInt(event.target.min) || 40;
                const max = parseInt(event.target.max) || 300;
                if (newBPM < min) { event.target.value = min; return; }
                if (newBPM > max) { event.target.value = max; return; }
                
                updateBPMDisplay(newBPM);
                initialBPM = newBPM;
                if (isRunning) {
                    currentBPM = newBPM; 
                }
            };
            
            bpmInput.addEventListener('input', bpmChangeHandler);
            bpmSlider.addEventListener('input', bpmChangeHandler);
            
            // Aggiunge listener generici agli input numerici per gestire min/max
            const numberInputs = [timerMinutesInput, timerSecondsInput, measuresForAccelerationInput, bpmIncreaseInput];
            numberInputs.forEach(input => {
                input.addEventListener('input', (e) => {
                    let val = parseInt(e.target.value);
                    const min = parseInt(e.target.min) || -Infinity;
                    const max = parseInt(e.target.max) || Infinity;
                    
                    if (e.target.id === 'timerSeconds') {
                        // Logica roll-over specifica
                        if (val < 0) val = 59;
                        if (val > 59) val = 0;
                    } else {
                        // Logica di clamp generica
                        if (val < min) val = min;
                        if (val > max) val = max;
                    }
                    e.target.value = val;
                });
            });

            // PWA: Registra il service worker
            const serviceWorkerContent = `
                const CACHE_NAME = 'metronome-cache-v6'; // Versione aggiornata
                const urlsToCache = ['/', 'https://cdn.tailwindcss.com'];
                self.addEventListener('install', event => { event.waitUntil(caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache))); });
                self.addEventListener('fetch', event => { event.respondWith(caches.match(event.request).then(response => response || fetch(event.request))); });
            `;
            const swBlob = new Blob([serviceWorkerContent], { type: 'application/javascript' });
            const swURL = URL.createObjectURL(swBlob);
            
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register(swURL, { scope: './' })
                        .then(registration => console.log('ServiceWorker registrato'))
                        .catch(err => console.log('Registrazione ServiceWorker fallita:', err));
                });
            }
        });

    </script>
</body>
</html>
