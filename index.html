<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metronomo Avanzato</title>
    <!-- Carica Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Stili personalizzati per la PWA */
        :root {
            /* Tema Scuro */
            --primary-color: #3b82f6; /* Blu di Tailwind 500 */
            --accent-color: #f97316; /* Arancione di Tailwind 500 */
            --bg-color: #1f2937; /* Grigio scuro/Nero */
            --card-color: #374151; /* Grigio medio scuro */
            --text-color: #f9fafb; /* Testo molto chiaro */
            --input-bg-color: #4b5563; /* Sfondo input scuro */
            --input-border-color: #6b7280;
            --tempo-text-color: #93c5fd; /* Blu chiaro/Viola come da foto */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            color: var(--text-color); /* Testo di base bianco */
        }

        .metronome-card {
            width: 100%;
            max-width: 500px;
            background-color: var(--card-color);
            border-radius: 1rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5), 0 10px 10px -5px rgba(0, 0, 0, 0.4);
            padding: 30px;
            transition: all 0.3s ease-in-out;
        }

        /* Classe per il contenitore delle etichette e input per l'allineamento verticale */
        .input-group-aligned {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            height: 100%;
        }

        .control-label {
            font-size: 0.875rem; /* text-sm */
            /* Rimosso font-semibold per rendere il nome dell'input non in grassetto */
            font-weight: 500; /* font-medium */
            color: var(--text-color); /* Etichette chiare */
        }

        input[type="number"] {
            appearance: textfield;
            -moz-appearance: textfield;
            background-color: var(--input-bg-color);
            border-color: var(--input-border-color);
            color: var(--text-color);
            height: 40px; /* Altezza uniforme per tutti gli input */
        }
        
        input[type="number"]::-webkit-inner-spin-button, 
        input[type="number"]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }

        /* Stile personalizzato per lo slider di input[range] */
        input[type=range] {
          -webkit-appearance: none;
          width: 100%;
          background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
          -webkit-appearance: none;
          height: 24px; /* Thumb più grande */
          width: 24px;
          border-radius: 50%;
          background: var(--primary-color);
          cursor: pointer;
          margin-top: -10px; /* Spostato per centrare */
          box-shadow: 0 0 5px rgba(0, 0, 0, 0.4);
        }
        input[type=range]::-webkit-slider-runnable-track {
          width: 100%;
          height: 4px;
          cursor: pointer;
          background: #4b5563; /* Traccia più scura */
          border-radius: 2px;
        }

        /* Pallini Battito PIÙ GRANDI (48px) */
        .beat-dot {
            width: 48px; 
            height: 48px;
            background-color: #4b5563; /* Grigio scuro a riposo */
            border-radius: 50%;
            transition: background-color 0.1s, transform 0.1s;
        }
        
        /* Animazione di pulsazione ridimensionata per i 48px */
        .beat-dot.scale-120 { 
            transform: scale(1.15); 
        }

        .beat-dot.strong {
            background-color: var(--accent-color); /* Arancione per il primo battito */
            box-shadow: 0 0 20px var(--accent-color); /* Ombra aumentata */
        }

        .beat-dot.weak {
            background-color: var(--primary-color); /* Blu per i battiti deboli */
            box-shadow: 0 0 20px var(--primary-color); /* Ombra aumentata */
        }
        
        /* Stili per il Toggle */
        .toggle-label {
            background-color: #6b7280 !important; /* Grigio scuro per off */
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: var(--primary-color) !important;
        }
        
        /* Stile per l'indicatore dinamico di tempo */
        .dynamic-tempo-text {
            height: 24px;
            font-size: 1.25rem; /* text-xl */
            font-weight: 700; /* font-bold */
            color: var(--tempo-text-color); /* Colore dinamico come da foto */
            margin-top: 24px;
            margin-bottom: 4px;
        }

    </style>
</head>
<body>

    <div id="app" class="metronome-card">
        <h1 class="text-3xl font-bold mb-6 text-center text-gray-100">Metronomo</h1>
        
        <!-- Indicatore del BPM Corrente e del Tempo -->
        <div class="text-center mb-8">
            <p class="text-6xl font-extrabold" id="displayBPM">120</p>
            <!-- Dimensione ridotta da text-lg a text-sm come richiesto -->
            <p class="text-sm text-gray-300 mt-1" id="currentBPMText">BPM Corrente</p>
        </div>

        <!-- Indicatori del Battito -->
        <div id="beatIndicators" class="flex justify-center space-x-4">
            <!-- I pallini verranno generati qui -->
        </div>
        
        <!-- Indicatore del Tempo Dinamico -->
        <div class="text-center dynamic-tempo-text">
            <span id="tempoIndicatorText" class="tracking-widest">MODERATO</span>
        </div>


        <!-- Slider per la regolazione fine del BPM -->
        <div class="mb-8 px-1 relative">
            <input type="range" id="bpmSlider" min="40" max="300" value="120" 
                   class="w-full transition duration-150">
        </div>

        <!-- Controlli Principali (Allineati) -->
        <div class="grid grid-cols-2 gap-4 mb-6">
            
            <!-- Campo BPM Iniziale -->
            <div class="input-group-aligned">
                <label for="bpm" class="control-label">BPM Iniziale</label>
                <input type="number" id="bpm" value="120" min="40" max="300" 
                       class="w-full border rounded-lg p-2 text-center focus:ring-blue-500 focus:border-blue-500 transition duration-150">
            </div>

            <!-- Campo Battiti per Misura (Time Signature) -->
            <div class="input-group-aligned">
                <label for="beatsPerMeasure" class="control-label">Battiti per Misura</label>
                <input type="number" id="beatsPerMeasure" value="4" min="2" max="12" 
                       class="w-full border rounded-lg p-2 text-center focus:ring-blue-500 focus:border-blue-500 transition duration-150">
            </div>
        </div>
        
        <!-- Pulsante START/STOP e Tap Tempo -->
        <div class="flex space-x-4 mb-6">
            <button id="startButton" class="flex-grow text-white font-bold py-3 px-4 rounded-xl 
                                         bg-green-500 hover:bg-green-600 active:bg-green-700 
                                         transition duration-150 shadow-lg shadow-green-500/50">
                INIZIA
            </button>
            <button id="tapTempoButton" class="w-1/4 text-white font-bold py-3 px-4 rounded-xl 
                                                bg-orange-500 hover:bg-orange-600 active:bg-orange-700 
                                                transition duration-150 shadow-lg shadow-orange-500/50 text-sm">
                TAP TEMPO
            </button>
        </div>
        
        <!-- Toggle per l'Accelerazione Progressiva -->
        <div class="mb-6 flex items-center justify-between p-3 bg-gray-600 rounded-lg shadow-inner">
            <label for="progressiveAccelerationToggle" class="text-sm font-semibold text-gray-100">Accelerazione Progressiva</label>
            <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                <input type="checkbox" name="toggle" id="progressiveAccelerationToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" />
                <label for="progressiveAccelerationToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
            </div>
        </div>

        <!-- Controlli di Accelerazione (Visibilità Condizionale e Allineati) -->
        <div id="accelerationControls" class="grid grid-cols-2 gap-4 mb-8 hidden">
            
            <!-- Campo Misure per Accelerazione -->
            <div class="input-group-aligned">
                <label for="measuresForAcceleration" class="control-label">Misure per accel.</label>
                <input type="number" id="measuresForAcceleration" value="4" min="1" 
                       class="w-full border rounded-lg p-2 text-center focus:ring-blue-500 focus:border-blue-500 transition duration-150">
            </div>

            <!-- Campo Aumento BPM -->
            <div class="input-group-aligned">
                <label for="bpmIncrease" class="control-label">Aumento BPM</label>
                <input type="number" id="bpmIncrease" value="5" min="1" 
                       class="w-full border rounded-lg p-2 text-center focus:ring-blue-500 focus:border-blue-500 transition duration-150">
            </div>
        </div>
        
        <!-- Messaggio di Stato (per feedback) -->
        <div id="statusMessage" class="mt-4 p-3 bg-blue-800 border border-blue-600 text-blue-100 rounded-lg text-sm hidden">
            Stato: Pronto
        </div>

        <!-- Custom styles for the toggle switch (mantenuto per la funzionalità) -->
        <style>
            .toggle-checkbox {
                opacity: 0;
                width: 0;
                height: 0;
            }
            .toggle-label {
                position: relative;
                display: block;
                height: 1.5rem;
                width: 2.5rem;
                border-radius: 9999px;
                cursor: pointer;
                transition: background-color 0.2s ease;
            }
            .toggle-label:before {
                content: '';
                position: absolute;
                top: 2px;
                left: 2px;
                height: 1.25rem;
                width: 1.25rem;
                border-radius: 50%;
                background: white;
                transition: transform 0.2s ease;
            }
            .toggle-checkbox:checked + .toggle-label {
                background-color: var(--primary-color);
            }
            .toggle-checkbox:checked + .toggle-label:before {
                transform: translateX(1rem);
            }
        </style>
    </div>

    <script>
        // Variabili globali per l'audio e il timer
        let audioContext;
        let timerWorker;
        let isRunning = false;
        let currentBPM = 120;
        let currentBeat = 0;
        let currentMeasure = 0;
        
        // Configurazioni
        let lookahead = 25.0; // Guarda in avanti di 25 ms
        let scheduleAheadTime = 0.1; // Pianifica 100 ms in anticipo

        // Stato Tap Tempo
        let tapTimes = [];
        const TAP_MAX_DIFF = 2000; // Max 2 secondi tra i tap
        const TAP_MIN_COUNT = 3; // Minimo 3 tap per calcolare il BPM

        // Stato dell'App
        let nextNoteTime = 0.0; // La prossima nota programmata
        let beatsPerMeasure = 4;
        let progressiveAcceleration = false;
        let measuresForAcceleration = 4;
        let bpmIncrease = 5;
        let initialBPM = 120;
        
        // Elementi DOM
        const appDiv = document.getElementById('app');
        const startButton = document.getElementById('startButton');
        const tapTempoButton = document.getElementById('tapTempoButton');
        const displayBPM = document.getElementById('displayBPM');
        const beatIndicatorsDiv = document.getElementById('beatIndicators');
        const tempoIndicatorText = document.getElementById('tempoIndicatorText'); // Elemento di testo di tempo
        const bpmInput = document.getElementById('bpm');
        const bpmSlider = document.getElementById('bpmSlider');
        const beatsPerMeasureInput = document.getElementById('beatsPerMeasure');
        const accelerationControls = document.getElementById('accelerationControls');
        const progressiveAccelerationToggle = document.getElementById('progressiveAccelerationToggle');
        const measuresForAccelerationInput = document.getElementById('measuresForAcceleration');
        const bpmIncreaseInput = document.getElementById('bpmIncrease');
        const statusMessage = document.getElementById('statusMessage');
        
        // Definizioni dei tempi musicali (Limiti inferiori e superiori)
        // Aggiornato per riflettere gli intervalli BPM e il nome minuscolo come da richiesta
        const tempoMap = [
            { minBPM: 40, maxBPM: 60, name: "Largo" },
            { minBPM: 61, maxBPM: 76, name: "Adagio" },
            { minBPM: 77, maxBPM: 108, name: "Andante" },
            { minBPM: 109, maxBPM: 120, name: "Moderato" },
            { minBPM: 121, maxBPM: 168, name: "Allegro" },
            { minBPM: 169, maxBPM: 200, name: "Presto" },
            { minBPM: 201, maxBPM: 300, name: "Prestissimo" }
        ];

        // --- Funzioni Audio ---

        /**
         * Crea un suono a onda quadra per un singolo battito.
         */
        function playBeat(time, frequency, duration) {
            if (!audioContext) return;

            const osc = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            osc.connect(gainNode);
            gainNode.connect(audioContext.destination);

            osc.type = "square";
            osc.frequency.setValueAtTime(frequency, time);

            // Controllo del volume (gain)
            gainNode.gain.setValueAtTime(0, time);
            gainNode.gain.linearRampToValueAtTime(0.5, time + 0.001); // Attacco rapido
            gainNode.gain.exponentialRampToValueAtTime(0.001, time + duration); // Rilascio rapido

            osc.start(time);
            osc.stop(time + duration);
        }

        /**
         * Pianifica la prossima nota.
         */
        function scheduleNote() {
            let noteLength = 60.0 / currentBPM;
            let noteFrequency = 440; // Tono debole
            let noteDuration = 0.05; // Durata breve del clic

            // Calcola il prossimo battito
            currentBeat = (currentBeat + 1) % beatsPerMeasure;
            
            if (currentBeat === 0) {
                // Primo battito della misura (Forte)
                noteFrequency = 880;
                currentMeasure++;
            } else {
                // Altri battiti (Debole)
                noteFrequency = 440;
            }

            // Riproduci il battito
            playBeat(nextNoteTime, noteFrequency, noteDuration);
            
            // Aggiorna la UI al momento della riproduzione
            // Esegue l'aggiornamento UI sul thread principale tramite un messaggio
            // Questo assicura che il DOM sia modificato nel modo corretto
            postMessageToMainThread({ type: 'updateUI', beat: currentBeat, bpm: currentBPM });
            
            // Aggiorna il tempo per la nota successiva
            nextNoteTime += noteLength;

            // Logica di accelerazione (solo se il metronomo è in esecuzione)
            if (progressiveAcceleration && currentBeat === 0) {
                if (currentMeasure % measuresForAcceleration === 0 && currentMeasure > 0) {
                    currentBPM += bpmIncrease;
                    // L'aggiornamento del BPM visivo verrà gestito in postMessageToMainThread
                }
            }
        }

        /**
         * Funzione principale di pianificazione del metronomo.
         */
        function scheduler() {
            // Finché c'è tempo da pianificare nel futuro
            while (nextNoteTime < audioContext.currentTime + scheduleAheadTime) {
                scheduleNote();
            }
        }

        // --- Gestione UI e Worker Thread ---

        /**
         * Invia un messaggio al thread principale per aggiornare la UI.
         */
        function postMessageToMainThread(data) {
            if (typeof window !== 'undefined' && window.requestAnimationFrame) {
                window.requestAnimationFrame(() => handleWorkerMessage(data));
            }
        }
        
        /**
         * Gestisce i messaggi dal Worker (o chiamati direttamente per l'UI update).
         */
        function handleWorkerMessage(e) {
            if (e.type === 'updateUI') {
                updateBeatIndicators(e.beat);
                if (e.bpm !== parseInt(displayBPM.textContent)) {
                    // Aggiorna BPM se l'accelerazione è attiva
                    updateBPMDisplay(e.bpm);
                }
            }
        }
        
        /**
         * Aggiorna tutti gli indicatori BPM e il testo di tempo.
         */
        function updateBPMDisplay(bpmValue) {
            const newBPM = parseInt(bpmValue);
            if (newBPM < 40 || newBPM > 300) return; // Limiti
            
            displayBPM.textContent = newBPM;
            bpmInput.value = newBPM;
            bpmSlider.value = newBPM;
            
            // Aggiorna l'indicatore di tempo dinamico
            tempoIndicatorText.textContent = getTempoName(newBPM);
        }

        /**
         * Determina il nome del tempo in base al BPM.
         */
        function getTempoName(bpm) {
            let tempoEntry = tempoMap.find(entry => bpm >= entry.minBPM && bpm <= entry.maxBPM);
            
            if (tempoEntry) {
                const name = tempoEntry.name;
                const minBPM = tempoEntry.minBPM;
                const maxBPM = tempoEntry.maxBPM;
                
                // Formatta in minuscolo e con l'intervallo BPM tra parentesi
                const formattedName = name.charAt(0) + name.slice(1).toLowerCase();
                return `${formattedName} (${minBPM}-${maxBPM})`;
            }
            
            // Gestione dei limiti estremi (molto lento o molto veloce)
            if (bpm < tempoMap[0].minBPM) {
                const name = tempoMap[0].name;
                return `${name.charAt(0) + name.slice(1).toLowerCase()} (<${tempoMap[0].minBPM})`;
            }
             if (bpm > tempoMap[tempoMap.length - 1].maxBPM) {
                const name = tempoMap[tempoMap.length - 1].name;
                return `${name.charAt(0) + name.slice(1).toLowerCase()} (>${tempoMap[tempoMap.length - 1].maxBPM})`;
            }
            
            return "Tempo Sconosciuto";
        }


        // --- Funzioni UI e Logica ---

        function setupBeatIndicators() {
            beatIndicatorsDiv.innerHTML = '';
            for (let i = 0; i < beatsPerMeasure; i++) {
                const dot = document.createElement('div');
                // Uso di scale-120 per il nuovo size dei pallini
                dot.classList.add('beat-dot', 'transform', 'scale-100'); 
                dot.id = `dot-${i}`;
                beatIndicatorsDiv.appendChild(dot);
            }
        }

        function updateBeatIndicators(beat) {
            const dots = beatIndicatorsDiv.querySelectorAll('.beat-dot');
            dots.forEach(dot => {
                dot.classList.remove('strong', 'weak', 'scale-120');
                dot.classList.add('scale-100');
            });

            // L'indice 0 è il primo battito, ma l'array è 0-based
            const currentDotIndex = beat; 
            const currentDot = document.getElementById(`dot-${currentDotIndex}`);
            
            if (currentDot) {
                if (currentDotIndex === 0) {
                    currentDot.classList.add('strong', 'scale-120');
                } else {
                    currentDot.classList.add('weak', 'scale-120');
                }
            }
        }

        /**
         * Aggiorna lo stato di visibilità dei controlli di accelerazione.
         */
        function updateAccelerationControlsVisibility() {
            progressiveAcceleration = progressiveAccelerationToggle.checked;
            if (progressiveAcceleration) {
                accelerationControls.classList.remove('hidden');
            } else {
                accelerationControls.classList.add('hidden');
            }
        }

        /**
         * Gestisce l'evento click del pulsante START/STOP.
         */
        function toggleMetronome() {
            if (isRunning) {
                stopMetronome();
            } else {
                startMetronome();
            }
        }

        /**
         * Avvia il metronomo.
         */
        function startMetronome() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            // Aggiorna le configurazioni dall'UI
            initialBPM = parseInt(bpmInput.value) || 120;
            currentBPM = initialBPM;
            beatsPerMeasure = parseInt(beatsPerMeasureInput.value) || 4;
            progressiveAcceleration = progressiveAccelerationToggle.checked;
            measuresForAcceleration = parseInt(measuresForAccelerationInput.value) || 4;
            bpmIncrease = parseInt(bpmIncreaseInput.value) || 5;

            // Reset stato
            currentBeat = beatsPerMeasure - 1; // Iniziamo da -1 in modo che il primo battito sia 0
            currentMeasure = 0;
            nextNoteTime = audioContext.currentTime;

            setupBeatIndicators();
            updateBeatIndicators(0);
            updateBPMDisplay(currentBPM); // Aggiorna anche l'indicatore di tempo
            
            // Avvia il Worker per il timer
            timerWorker = new Worker(URL.createObjectURL(new Blob([`
                let timerID = null;
                let interval = ${lookahead};

                self.onmessage = function(e) {
                    if (e.data === "start") {
                        timerID = setInterval(function() {
                            postMessage("tick");
                        }, interval);
                    } else if (e.data === "stop") {
                        clearInterval(timerID);
                        timerID = null;
                    }
                };
            `], { type: 'application/javascript' })));

            timerWorker.onmessage = function(e) {
                if (e.data === "tick") {
                    scheduler();
                }
            };
            
            timerWorker.postMessage("start");
            
            isRunning = true;
            startButton.textContent = "FERMA";
            startButton.classList.remove('bg-green-500', 'hover:bg-green-600', 'shadow-green-500/50');
            startButton.classList.add('bg-red-500', 'hover:bg-red-600', 'shadow-red-500/50');
            statusMessage.textContent = "Stato: In esecuzione";
            statusMessage.classList.remove('hidden');
        }

        /**
         * Ferma il metronomo.
         */
        function stopMetronome() {
            isRunning = false;

            if (timerWorker) {
                timerWorker.postMessage("stop");
                timerWorker.terminate();
                timerWorker = null;
            }
            
            // Reset UI
            startButton.textContent = "INIZIA";
            startButton.classList.remove('bg-red-500', 'hover:bg-red-600', 'shadow-red-500/50');
            startButton.classList.add('bg-green-500', 'hover:bg-green-600', 'shadow-green-500/50');
            updateBPMDisplay(initialBPM); // Torna al BPM iniziale e aggiorna il testo di tempo
            statusMessage.textContent = "Stato: Fermato. BPM Iniziale: " + initialBPM;
            
            // Rimuove l'evidenziazione dei battiti
            updateBeatIndicators(beatsPerMeasure); 
            
            // Reset BPM effettivo
            currentBPM = initialBPM;
        }

        /**
         * Calcola il BPM dal Tap Tempo e aggiorna la UI.
         */
        function handleTapTempo() {
            if (isRunning) {
                // Se in esecuzione, si ferma e riparte per applicare il nuovo BPM con l'audio worker
                stopMetronome();
                // NON si riavvia qui, si aggiorna solo il valore e si lascia all'utente decidere se riavviare
            }

            const now = Date.now();

            if (tapTimes.length > 0) {
                // Se l'ultimo tap è troppo vecchio, resetta
                if (now - tapTimes[tapTimes.length - 1] > TAP_MAX_DIFF) {
                    tapTimes = [];
                }
            }

            tapTimes.push(now);

            // Mantiene solo gli ultimi 5 tap per un calcolo più reattivo
            if (tapTimes.length > 5) {
                tapTimes.shift();
            }

            if (tapTimes.length >= TAP_MIN_COUNT) {
                let intervals = [];
                for (let i = 1; i < tapTimes.length; i++) {
                    intervals.push(tapTimes[i] - tapTimes[i-1]);
                }

                // Calcola la media degli intervalli in millisecondi
                const avgInterval = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length;

                // Calcola il BPM
                let calculatedBPM = Math.round(60000 / avgInterval);

                // Limita il BPM calcolato
                if (calculatedBPM < 40) calculatedBPM = 40;
                if (calculatedBPM > 300) calculatedBPM = 300;

                // Aggiorna l'UI (display, input, slider, tempo text)
                updateBPMDisplay(calculatedBPM);
                initialBPM = calculatedBPM; // Aggiorna il BPM iniziale per il prossimo avvio
                
                statusMessage.textContent = `Tap Tempo: ${calculatedBPM} BPM calcolato.`;
                statusMessage.classList.remove('hidden');

            } else {
                statusMessage.textContent = `Tap Tempo: Tocca ancora ${TAP_MIN_COUNT - tapTimes.length} volte.`;
                statusMessage.classList.remove('hidden');
            }
        }


        // --- Gestione Eventi e Inizializzazione ---

        document.addEventListener('DOMContentLoaded', () => {
            // Inizializza i pallini indicatori
            beatsPerMeasure = parseInt(beatsPerMeasureInput.value) || 4;
            setupBeatIndicators();
            updateAccelerationControlsVisibility(); // Nasconde/mostra i controlli all'avvio
            updateBPMDisplay(bpmInput.value); // Inizializza il testo di tempo all'avvio

            // Listener per il pulsante START/STOP
            startButton.addEventListener('click', toggleMetronome);
            
            // Listener per Tap Tempo
            tapTempoButton.addEventListener('click', handleTapTempo);

            // Listener per la visibilità condizionale
            progressiveAccelerationToggle.addEventListener('change', updateAccelerationControlsVisibility);

            // Listener per BPM Input (sincronizza con slider, display e testo di tempo)
            bpmInput.addEventListener('input', () => {
                const newBPM = parseInt(bpmInput.value) || 120;
                updateBPMDisplay(newBPM);
                initialBPM = newBPM;
                if (isRunning) {
                    currentBPM = newBPM; 
                }
            });

            // Listener per BPM Slider (sincronizza con input, display e testo di tempo)
            bpmSlider.addEventListener('input', () => {
                const newBPM = parseInt(bpmSlider.value) || 120;
                updateBPMDisplay(newBPM);
                initialBPM = newBPM;
                if (isRunning) {
                    currentBPM = newBPM; 
                }
            });

            // Listener per Battiti per Misura (aggiorna gli indicatori)
            beatsPerMeasureInput.addEventListener('input', () => {
                const newBeats = parseInt(beatsPerMeasureInput.value) || 4;
                beatsPerMeasure = newBeats;
                setupBeatIndicators();
            });
            
            // PWA: Registra il service worker (semplificato per l'ambiente a file unico)
            const serviceWorkerContent = `
                const CACHE_NAME = 'metronome-cache-v2';
                const urlsToCache = ['/', 'https://cdn.tailwindcss.com'];
                self.addEventListener('install', event => { event.waitUntil(caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache))); });
                self.addEventListener('fetch', event => { event.respondWith(caches.match(event.request).then(response => response || fetch(event.request))); });
            `;
            const swBlob = new Blob([serviceWorkerContent], { type: 'application/javascript' });
            const swURL = URL.createObjectURL(swBlob);
            
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register(swURL, { scope: './' })
                        .then(registration => console.log('ServiceWorker registrato'))
                        .catch(err => console.log('Registrazione ServiceWorker fallita:', err));
                });
            }
        });

    </script>
</body>
</html>
