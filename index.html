<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metronomo Avanzato</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Stili personalizzati per la PWA */
        :root {
            /* Tema Scuro */
            --primary-color: #3b82f6; /* Blu di Tailwind 500 */
            --accent-color: #f97316; /* Arancione di Tailwind 500 */
            --bg-color: #1f2937; /* Grigio scuro/Nero */
            --card-color: #2d3748; /* Grigio/Blu scuro per il riquadro */
            --text-color: #f9fafb; /* Testo molto chiaro */
            --input-bg-color: #4b5563; /* Sfondo input scuro */
            --input-border-color: #6b7280;
            --tempo-text-color: #93c5fd; /* Blu chiaro/Viola come da foto */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            color: var(--text-color);
        }

        .metronome-card {
            width: 100%;
            max-width: 500px;
            background-color: var(--card-color);
            border-radius: 1rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5), 0 10px 10px -5px rgba(0, 0, 0, 0.4);
            padding: 30px;
            transition: all 0.3s ease-in-out;
        }
        
        /* FIX: Rimuove lo sfondo della card su schermi piccoli (smartphone) */
        @media (max-width: 640px) {
            .metronome-card {
                background-color: transparent; 
                box-shadow: none; 
                padding: 20px 0;
            }
        }

        /* Classe per il contenitore delle etichette e input per l'allineamento verticale */
        .input-group-aligned {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            height: 100%;
        }

        .control-label {
            font-size: 0.875rem; 
            font-weight: 500; 
            color: var(--text-color);
            margin-bottom: 4px; 
        }

        /* Rimuove le frecce di default dagli input di tipo number */
        input[type="number"] {
            appearance: none;
            -moz-appearance: textfield;
            background-color: var(--input-bg-color); 
            border-color: var(--input-border-color); 
            color: var(--text-color);
            height: 3.5rem; 
            border: 1px solid var(--input-border-color); 
            border-radius: 0.5rem;
            padding: 0.5rem 0.75rem;
            text-align: center; 
        }
        
        input[type="number"]::-webkit-inner-spin-button, 
        input[type="number"]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }
        
        /* Stile per input BPM (type="text") */
        #bpm {
            background-color: transparent !important; 
            border: none !important; 
            box-shadow: none !important; 
            color: white !important; 
            font-size: 4rem !important; 
            font-weight: 900 !important; 
            height: auto !important; 
            width: 150px !important; 
            padding: 0 !important;
            margin: 0 1rem !important; 
            line-height: 1 !important;
            text-align: center !important;
        }

        /* --------------------------------- */
        /* SLIDER BPM E VOLUME (Track) */
        /* --------------------------------- */
        input[type=range] {
          -webkit-appearance: none;
          width: 100%;
          background: transparent;
        }
        /* MANOPOLA SLIDER PIÙ GRANDE */
        input[type=range]::-webkit-slider-thumb {
          -webkit-appearance: none;
          height: 32px; 
          width: 32px; 
          border-radius: 50%;
          background: var(--primary-color);
          cursor: pointer;
          margin-top: -14px; 
          box-shadow: 0 0 5px rgba(0, 0, 0, 0.4);
        }
        /* AGGIUNTO STILE MOZILLA PER COMPATIBILITÀ MANOPOLA */
        input[type=range]::-moz-range-thumb {
          height: 32px;
          width: 32px;
          border-radius: 50%;
          background: var(--primary-color);
          cursor: pointer;
          border: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
          width: 100%;
          height: 4px;
          cursor: pointer;
          background: #4b5563;
          border-radius: 2px;
        }
        
        /* Stili per il pulsante BPM tondo (GRANDE) */
        .circle-stepper-btn {
            width: 60px; height: 60px; border-radius: 50%; background-color: var(--card-color); color: var(--text-color); font-size: 2.5rem; font-weight: 300; display: flex; justify-content: center; align-items: center; cursor: pointer; border: 2px solid #4b5563; transition: background-color 0.15s, box-shadow 0.15s; line-height: 1; 
        }

        .bpm-input-stepper { display: flex; align-items: center; justify-content: center; margin-bottom: 0.5rem; }
        .bpm-display-group { display: flex; align-items: center; justify-content: center; flex-direction: column; margin-bottom: 1.5rem; }
        
        /* --------------------------------- */
        /* STILI STEPPER PICCOLI (TIMER/ACCEL) */
        /* --------------------------------- */
        
        .small-circle-stepper-btn {
            width: 40px; 
            height: 40px; 
            border-radius: 50%;
            background-color: var(--card-color);
            color: var(--text-color);
            font-size: 1.5rem; 
            font-weight: 300;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            border: 2px solid #4b5563; 
            transition: background-color 0.15s, box-shadow 0.15s;
            line-height: 1;
            flex-shrink: 0; 
        }
        
        .small-stepper-group { display: flex; align-items: center; justify-content: center; height: 3.5rem; border: none !important; background-color: transparent !important; padding: 0; }
        
        /* FIX: Aggiungo margine MINIMO per separare i pulsanti tondi dall'input */
        .small-stepper-group .small-circle-stepper-btn {
            margin: 0 2px; 
        }
        
        /* FIX: Riduco la larghezza dell'input e rimuovo i margini per ottimizzare lo spazio */
        .small-stepper-group input[type="number"] {
            background-color: transparent !important; border: none !important; box-shadow: none !important;
            color: white !important; font-size: 1.5rem !important; font-weight: 700 !important;
            height: 3.5rem !important; width: 60px !important; /* RIDOTTO: 60px */ padding: 0 !important;
            margin: 0 !important; /* Rimosso margine */ line-height: 1 !important; text-align: center !important; border-radius: 0.5rem !important; 
        }
        
        /* --------------------------------- */
        /* STILI TOGGLE SWITCH */
        /* --------------------------------- */
        .toggle-checkbox { opacity: 0; width: 0; height: 0; }
        .toggle-label {
            position: relative; display: block; height: 1.5rem; width: 2.5rem; border-radius: 9999px; cursor: pointer; transition: background-color 0.2s ease; background-color: #6b7280; 
        }
        .toggle-label:before {
            content: ''; position: absolute; top: 2px; left: 2px; height: 1.25rem; width: 1.25rem; border-radius: 50%; background: white; transition: transform 0.2s ease;
        }
        .toggle-checkbox:checked + .toggle-label { 
            background-color: var(--primary-color); 
        }
        .toggle-checkbox:checked + .toggle-label:before { 
            transform: translateX(1rem); 
        }
        
        /* --------------------------------- */
        /* STILI INDICATORI BATTITO (PALLINI) - DIMENSIONE MAGGIORATA E DINAMICA */
        /* --------------------------------- */
        
        /* NUOVO: Aggiunge spazio uniforme (16px) orizzontale e verticale tra gli elementi flex-wrap */
        #beatIndicators {
            gap: 1rem; 
        }
        
        .beat-dot {
            /* Dimensioni iniziali rimosse/modificate. Le dimensioni finali (64px o 60px) 
               saranno impostate dinamicamente dal JavaScript. */
            width: 28px; /* Mantengo le proprietà di base */
            height: 28px;
            border-radius: 50%;
            background-color: #4b5563; /* Grigio scuro (spento) */
            transition: background-color 0.05s ease, transform 0.05s ease;
        }

        .beat-dot.accent {
            background-color: var(--primary-color); /* Primo battito (Blu) */
            transform: scale(1.05); /* Ridotto leggermente per pallini grandi */
        }

        .beat-dot.strong {
            background-color: #fca5a5; /* Battiti successivi (Rosso chiaro) */
            transform: scale(1.03); /* Ridotto leggermente per pallini grandi */
        }
        
        /* Stili rimanenti */
        .dynamic-tempo-text { 
            height: 24px; 
            font-size: 1.25rem; 
            font-weight: 700; 
            color: var(--tempo-text-color); 
            margin-top: 12px; 
            margin-bottom: 4px; 
        }
        .tap-tempo-btn { background-color: #f97316; box-shadow: 0 4px 15px rgba(249, 115, 22, 0.4); }

        /* Stile specifico per il messaggio di stato di errore/stop */
        .status-error {
            background-color: #991b1b; /* Rosso Scuro */
            border-color: #b91c1c; 
        }

    </style>
</head>
<body>

    <div id="app" class="metronome-card">
        <h1 class="text-3xl font-bold mb-6 text-center text-gray-100">Metronomo</h1>
        
        <div id="timerDisplay" class="text-center text-3xl font-extrabold mb-4 text-red-400 hidden">
            00:00
        </div>
        
        <div class="bpm-display-group">
            <div class="bpm-input-stepper">
                <button type="button" id="bpmDownButton" 
                        class="circle-stepper-btn">-</button>
                <input type="text" id="bpm" value="120" min="40" max="300" pattern="[0-9]*" inputmode="numeric" data-step="1" class="new-bpm-input">
                <button type="button" id="bpmUpButton" 
                        class="circle-stepper-btn">+</button>
            </div>
            <p class="text-sm text-gray-300 mt-1" id="currentBPMText">BPM Corrente</p>
        </div>
        
        <div id="beatIndicators" class="flex justify-center mb-4 flex-wrap">
            </div>
        
        <div class="text-center dynamic-tempo-text">
            <span id="tempoIndicatorText" class="tracking-widest">MODERATO (109-120)</span>
        </div>


        <div class="mb-8 px-1 relative">
            <input type="range" id="bpmSlider" min="40" max="300" value="120" 
                   class="w-full transition duration-150">
        </div>

        <div class="grid grid-cols-12 gap-4 mb-6">
            <button id="startButton" class="col-span-8 w-full text-white font-bold py-5 px-4 rounded-xl 
                                             bg-green-500 hover:bg-green-600 active:bg-green-700 
                                             transition duration-150 shadow-lg shadow-green-500/50">
                INIZIA
            </button>
            <button id="tapTempoButton" class="col-span-4 w-full text-white font-bold py-5 px-4 rounded-xl 
                                                tap-tempo-btn 
                                                transition duration-150 shadow-lg">
                TAP TEMPO
            </button>
        </div>

        <div class="grid grid-cols-2 gap-4 mb-6">
            
            <div class="input-group-aligned relative">
                <label for="timeSignatureSelect" class="control-label">Battiti per Misura</label>
                <select id="timeSignatureSelect" class="w-full appearance-none pr-8 text-center bg-gray-600 h-14 rounded-lg border border-gray-500 text-white">
                    <option value="2">2/4</option>
                    <option value="3">3/4</option>
                    <option value="4" selected>4/4</option>
                    <option value="5">5/4</option>
                    <option value="6">6/8</option>
                    <option value="7">7/4</option>
                    <option value="8">8/4</option>
                    <option value="9">9/8</option>
                    <option value="12">12/8</option>
                    </select>
                <div class="absolute inset-y-0 right-0 top-[34px] flex items-center px-2 pointer-events-none">
                    <svg class="w-4 h-4 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
            </div>
            
            <div class="input-group-aligned relative">
                <label for="subdivisionSelect" class="control-label">Suddivisione</label>
                <select id="subdivisionSelect" class="w-full appearance-none pr-8 text-center bg-gray-600 h-14 rounded-lg border border-gray-500 text-white">
                    <option value="1" selected>Semiminima (♩)</option>
                    <option value="2">Croma (♪)</option>
                    <option value="3">Terzina (♩³)</option>
                    <option value="4">Semicroma (♬)</option>
                </select>
                <div class="absolute inset-y-0 right-0 top-[34px] flex items-center px-2 pointer-events-none">
                    <svg class="w-4 h-4 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
            </div>
            
        </div>
        
        <div id="muteSubdivisionsContainer" class="mb-4 flex items-center justify-between p-3 bg-gray-600 rounded-lg shadow-inner">
            <label for="muteSubdivisionsToggle" class="text-sm font-semibold text-gray-100">Muta Suddivisioni</label>
            <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                <input type="checkbox" name="toggle" id="muteSubdivisionsToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" />
                <label for="muteSubdivisionsToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
            </div>
        </div>

        <div id="subdivisionVolumeControls" class="mb-4">
            <label for="subdivisionVolumeSlider" class="control-label mb-2 block">Volume Suddivisioni</label>
            <input type="range" id="subdivisionVolumeSlider" min="0" max="1" step="0.05" value="0.5" 
                   class="w-full transition duration-150">
        </div>
        <div class="mb-4 flex items-center justify-between p-3 bg-gray-600 rounded-lg shadow-inner">
            <label for="timerToggle" class="text-sm font-semibold text-gray-100">Attiva Timer</label>
            <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                <input type="checkbox" name="timerToggle" id="timerToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" />
                <label for="timerToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
            </div>
        </div>

        <div id="timerControls" class="grid grid-cols-2 gap-4 mb-6 hidden">
            <div class="input-group-aligned">
                <label for="timerMinutes" class="control-label">Minuti</label>
                <div class="small-stepper-group w-full">
                    <button type="button" id="timerMinutesDown" 
                            class="small-circle-stepper-btn">-</button>
                    <input type="number" id="timerMinutes" value="1" min="0" max="99" data-step="1" class="input-to-validate" data-val-type="timerMinutes">
                    <button type="button" id="timerMinutesUp" 
                            class="small-circle-stepper-btn">+</button>
                </div>
            </div>
            
            <div class="input-group-aligned">
                <label for="timerSeconds" class="control-label">Secondi</label>
                <div class="small-stepper-group w-full">
                    <button type="button" id="timerSecondsDown" 
                            class="small-circle-stepper-btn">-</button>
                    <input type="number" id="timerSeconds" value="0" min="0" max="59" data-step="1" class="input-to-validate" data-val-type="timerSeconds">
                    <button type="button" id="timerSecondsUp" 
                            class="small-circle-stepper-btn">+</button>
                </div>
            </div>
        </div>

        <div class="mb-4 flex items-center justify-between p-3 bg-gray-600 rounded-lg shadow-inner">
            <label for="progressiveAccelerationToggle" class="text-sm font-semibold text-gray-100">Accelerazione Progressiva</label>
            <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                <input type="checkbox" name="toggle" id="progressiveAccelerationToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" />
                <label for="progressiveAccelerationToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
            </div>
        </div>

        <div id="accelerationControls" class="grid grid-cols-2 gap-4 mb-8 hidden">
            
            <div class="input-group-aligned">
                <label for="measuresForAcceleration" class="control-label">Misure per accel.</label>
                <div class="small-stepper-group w-full">
                    <button type="button" id="measuresForAccelerationDown" 
                            class="small-circle-stepper-btn">-</button>
                    <input type="number" id="measuresForAcceleration" value="1" min="1" data-step="1" class="input-to-validate" data-val-type="measuresForAcceleration">
                    <button type="button" id="measuresForAccelerationUp" 
                            class="small-circle-stepper-btn">+</button>
                </div>
            </div>

            <div class="input-group-aligned">
                <label for="bpmIncrease" class="control-label">Aumento BPM</label>
                <div class="small-stepper-group w-full">
                    <button type="button" id="bpmIncreaseDown" 
                            class="small-circle-stepper-btn">-</button>
                    <input type="number" id="bpmIncrease" value="1" min="1" data-step="1" class="input-to-validate" data-val-type="bpmIncrease">
                    <button type="button" id="bpmIncreaseUp" 
                            class="small-circle-stepper-btn">+</button>
                </div>
            </div>

        </div>
        
        <div id="statusMessage" class="mt-4 p-3 bg-blue-800 border border-blue-600 text-blue-100 rounded-lg text-sm hidden">
            Stato: Pronto
        </div>
    </div>

    <script>
        // ====================================================
        // VARIABILI GLOBALI E CONFIGURAZIONE METRONOMO
        // ====================================================
        let audioContext = null;
        let isRunning = false;
        let initialBPM = 120;
        let beatsPerMeasure = 4;
        let subdivisionFactor = 1; 
        let totalSubBeats = 4; 
        let currentSubBeat = 0;
        let timerWorker = null;
        let nextBeatTime = 0.0;
        const LOOKAHEAD = 25.0; // in ms
        const SCHEDULE_AHEAD_TIME = 0.1; // in seconds
        
        // Nuove costanti di guadagno
        const MAIN_BEAT_GAIN = 0.7; // Volume per i battiti successivi al primo (e.g., battiti 2, 3, 4 del 4/4)
        let subdivisionGain = 0.5; // NUOVO: Volume dinamico per le suddivisioni
        
        // NUOVA VARIABILE per mutare le suddivisioni
        let isSubdivisionMuted = false;
        
        // Variabili Stepper
        let pressTimer = null;
        let pressInterval = null;
        const INITIAL_DELAY = 400; 
        const REPEAT_INTERVAL = 100; 
        
        // Variabili Tap Tempo
        let tapTimes = [];
        const MAX_TAPS = 4; 
        
        // Variabili Timer
        let remainingTimerSeconds = 0; 
        let timerDurationSeconds = 60; 
        let isTimerActive = false;
        let timerCountdownInterval = null;
        let timerStartTime = 0; 
        
        // Variabili Accelerazione
        let isAccelerationActive = false;
        let measuresCounter = 0; // Il contatore tiene traccia delle misure *completate* nel ciclo
        let measuresToAccelerate = 1;
        let bpmIncreaseAmount = 1;
        
        // Memorizza gli ultimi valori validi degli input secondari
        let lastValidValues = {
            timerMinutes: 1,
            timerSeconds: 0,
            measuresForAcceleration: 1,
            bpmIncrease: 1
        };

        const tempoMap = [
            { minBPM: 40, maxBPM: 60, name: "Largo" },
            { minBPM: 61, maxBPM: 76, name: "Adagio" },
            { minBPM: 77, maxBPM: 108, name: "Andante" },
            { minBPM: 109, maxBPM: 120, name: "Moderato" },
            { minBPM: 121, maxBPM: 168, name: "Allegro" },
            { minBPM: 169, maxBPM: 200, name: "Presto" },
            { minBPM: 201, maxBPM: 300, name: "Prestissimo" }
        ];

        // ====================================================
        // FUNZIONI AUDIO (GENERAZIONE SUONO E SCHEDULING)
        // ====================================================

        /**
         * Suona un click al tempo specificato con frequenza e guadagno specifici.
         * @param {number} time - Il tempo di esecuzione.
         * @param {number} frequency - La frequenza (tono) del click.
         * @param {number} gainValue - Il guadagno (volume) del click.
         */
        function playClick(time, frequency, gainValue) {
            if (!audioContext) return;
            
            const osc = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            osc.connect(gainNode);
            gainNode.connect(audioContext.destination);

            osc.frequency.setValueAtTime(frequency, time);
            
            // Envelope per un click secco con volume dinamico
            gainNode.gain.setValueAtTime(gainValue, time); // Usa il guadagno calcolato
            gainNode.gain.exponentialRampToValueAtTime(0.001, time + 0.03); 
            
            osc.start(time);
            osc.stop(time + 0.03);
        }

        function scheduler() {
            while (nextBeatTime < audioContext.currentTime + SCHEDULE_AHEAD_TIME) {
                
                // Variabili di stato battito
                const isMainBeat = currentSubBeat % subdivisionFactor === 0;
                const isFirstBeatOfMeasure = currentSubBeat === 0;
                
                // Calcola la frequenza e il guadagno del suono
                let frequency = 440; // Default: tono base
                let gainValue = subdivisionGain; // Default: volume suddivisioni (utilizza subdivisionGain)

                if (isMainBeat) {
                    const beatIndex = currentSubBeat / subdivisionFactor;
                    if (isFirstBeatOfMeasure) {
                        frequency = 880; // Primo battito (forte)
                        gainValue = 1; // Volume massimo
                        setTimeout(() => animateBeat(beatIndex, 'accent'), 0);
                        
                        // --- Logica Accelerazione ---
                        if (isAccelerationActive) {
                            
                            // Se il contatore è GIA' >= al target, è ora di accelerare per la misura che sta per iniziare
                            if (measuresCounter >= measuresToAccelerate) {
                                
                                const maxBPM = parseInt(document.getElementById('bpm').max) || 300;
                                let newBPM = initialBPM + bpmIncreaseAmount;
                                
                                if (newBPM <= maxBPM) {
                                    // CHIAMATA AGGIORNATA: Non usa isTextualInput, quindi aggiorna il campo BPM
                                    updateBPMDisplay(newBPM); 
                                } else {
                                    // Raggiunto BPM massimo
                                    isAccelerationActive = false;
                                    document.getElementById('progressiveAccelerationToggle').checked = false;
                                    const statusMessage = document.getElementById('statusMessage');
                                    statusMessage.textContent = `Accelerazione fermata, raggiunto BPM massimo (${maxBPM}).`;
                                    statusMessage.classList.remove('hidden', 'bg-blue-800'); 
                                    statusMessage.classList.add('status-error'); 
                                }
                                
                                // Reset a 1: la misura che sta per partire (accelerata) è la prima del nuovo ciclo
                                measuresCounter = 1; 
                            } else {
                                // Se l'accelerazione non è ancora dovuta, incrementa il contatore per la misura che sta per partire
                                measuresCounter++;
                            }
                        }
                        // --- Fine Logica Accelerazione ---
                        
                    } else {
                        frequency = 660; // Battiti successivi (medi)
                        gainValue = MAIN_BEAT_GAIN; // Volume intermedio
                        setTimeout(() => animateBeat(beatIndex, 'strong'), 0);
                    }
                } else {
                    frequency = 440; // Suddivisione (debole)
                    // USA subdivisionGain: Muta le suddivisioni se il toggle è attivo
                    gainValue = isSubdivisionMuted ? 0 : subdivisionGain; 
                }

                playClick(nextBeatTime, frequency, gainValue); // Passa il guadagno

                // Aggiorna il tempo del prossimo battito (usa initialBPM aggiornato)
                const secondsPerSubBeat = 60.0 / (initialBPM * subdivisionFactor); 
                nextBeatTime += secondsPerSubBeat;

                // Aggiorna il contatore del sub-battito
                currentSubBeat = (currentSubBeat + 1) % totalSubBeats;
            }
        }
        
        function animateBeat(beatIndex, type) {
            // Seleziona il dot tramite l'ID sequenziale
            const currentDot = document.getElementById(`dot-${beatIndex}`);
            
            if (currentDot) {
                currentDot.classList.add(type);
                
                // DURATA ANIMAZIONE: si basa sul LOOKAHEAD (25ms) + un piccolo margine
                setTimeout(() => {
                    currentDot.classList.remove('accent', 'strong');
                }, 100); 
            }
        }
        
        // ====================================================
        // FUNZIONE TAP TEMPO
        // ====================================================
        function handleTapTempo() {
            const now = Date.now();
            const statusMessage = document.getElementById('statusMessage');

            if (tapTimes.length > 0 && (now - tapTimes[tapTimes.length - 1]) > 2000) {
                tapTimes = []; 
            }

            tapTimes.push(now);
            if (tapTimes.length > MAX_TAPS) {
                tapTimes.shift(); 
            }

            if (tapTimes.length >= 3) {
                let totalInterval = 0;
                for (let i = 1; i < tapTimes.length; i++) {
                    totalInterval += tapTimes[i] - tapTimes[i - 1];
                }

                const averageInterval = totalInterval / (tapTimes.length - 1);
                
                let newBPM = Math.round(60000 / averageInterval);
                
                const minBPM = 40;
                const maxBPM = 300;
                if (newBPM < minBPM) newBPM = minBPM;
                if (newBPM > maxBPM) newBPM = maxBPM;
                
                // Aggiorna sia lo stato interno che l'input field/slider
                // CHIAMATA AGGIORNATA: Non usa isTextualInput, quindi aggiorna il campo BPM (clammato)
                updateBPMDisplay(newBPM); 
                
                statusMessage.textContent = `BPM impostato a ${newBPM}.`;
                statusMessage.classList.remove('hidden', 'status-error');
                statusMessage.classList.add('bg-blue-800');
            } else {
                statusMessage.textContent = `Tocca 3 o più volte per calcolare il BPM (Taps: ${tapTimes.length}).`;
                statusMessage.classList.remove('hidden', 'status-error');
                statusMessage.classList.add('bg-blue-800');
            }
        }


        // ====================================================
        // CONTROLLO START/STOP & LOGICA FUNZIONALITÀ
        // ====================================================

        function updateTimerDisplay() {
            const minutes = Math.floor(remainingTimerSeconds / 60);
            const seconds = remainingTimerSeconds % 60;
            const display = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('timerDisplay').textContent = display;
        }

        /**
         * Aggiorna lo stato del timer (durata, intervallo, visualizzazione)
         * e viene chiamata su ogni modifica (input, stepper, toggle).
         */
        function updateTimerDuration() {
            const minutesInput = document.getElementById('timerMinutes');
            const secondsInput = document.getElementById('timerSeconds');
            
            // LEGGE i valori correnti dall'input
            const minutes = parseInt(minutesInput.value) || 0;
            const seconds = parseInt(secondsInput.value) || 0;
            
            // Aggiorna la durata totale basata sui nuovi valori
            const newTotalDuration = (minutes * 60) + seconds;
            
            isTimerActive = document.getElementById('timerToggle').checked; 
            
            // AGGIORNAMENTO DURATA TOTALE E STATO SE METRONOMO FERMO O TIMER DISATTIVATO
            if (!isRunning || !isTimerActive) {
                timerDurationSeconds = newTotalDuration;
                remainingTimerSeconds = newTotalDuration;
                updateTimerDisplay(); // Mostra la durata impostata
                if (timerCountdownInterval) {
                    clearInterval(timerCountdownInterval);
                    timerCountdownInterval = null;
                }
                return; 
            }


            // LOGICA DI AGGIORNAMENTO DINAMICO QUANDO IS_RUNNING
            if (isRunning && isTimerActive) {
                
                if (newTotalDuration <= 0) {
                    if (timerCountdownInterval) clearInterval(timerCountdownInterval);
                    // Ritorna alla durata precedente in caso di 0, per evitare stop accidentali
                    timerDurationSeconds = 1; 
                    remainingTimerSeconds = 1; 
                    updateTimerDisplay();
                    return;
                }
                
                // 1. Calcola il tempo trascorso con precisione (in secondi interi)
                const timeElapsedMs = Date.now() - timerStartTime;
                const timeElapsedSec = Math.floor(timeElapsedMs / 1000); 

                // 2. Imposta la nuova durata totale
                timerDurationSeconds = newTotalDuration;
                
                // 3. Calcola i secondi rimanenti sulla base della NUOVA durata e del tempo trascorso
                remainingTimerSeconds = timerDurationSeconds - timeElapsedSec;

                if (remainingTimerSeconds <= 0) {
                    // Se il tempo residuo è negativo (durata totale ridotta troppo o tempo esaurito)
                    if (timerCountdownInterval) clearInterval(timerCountdownInterval);
                    startStopMetronome();
                    return;
                }
                
                // Riavvia l'intervallo con il tempo rimanente ricalcolato
                if (timerCountdownInterval) {
                    clearInterval(timerCountdownInterval);
                }
                
                document.getElementById('timerDisplay').classList.remove('hidden');
                updateTimerDisplay();

                // Riavvia l'intervallo e aggiorna anche timerStartTime per il prossimo ricalcolo/tick
                timerCountdownInterval = setInterval(() => {
                    const currentElapsedSec = Math.floor((Date.now() - timerStartTime) / 1000);
                    remainingTimerSeconds = timerDurationSeconds - currentElapsedSec;
                    
                    updateTimerDisplay();
                    
                    if (remainingTimerSeconds <= 0) {
                        clearInterval(timerCountdownInterval);
                        startStopMetronome(); 
                    }
                }, 100); // Intervallo a 100ms per maggiore reattività e precisione nel calcolo
            }
        }


        function startStopMetronome() {
            const startButton = document.getElementById('startButton');
            
            if (!isRunning) {
                // AVVIO
                if (audioContext === null) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                audioContext.resume(); 

                // 1. Assicurati che tutti gli input siano clammati e validi all'avvio
                clampAndSetFinalBPM(); 
                clampAndSetFinalValue(document.getElementById('timerMinutes'));
                clampAndSetFinalValue(document.getElementById('timerSeconds'));
                clampAndSetFinalValue(document.getElementById('measuresForAcceleration'));
                clampAndSetFinalValue(document.getElementById('bpmIncrease'));
                
                // FIX ACCELERAZIONE: Sincronizza il BPM corrente con il campo di input
                initialBPM = parseInt(document.getElementById('bpm').value) || 120;
                
                // 2. Configurazione Iniziale (aggiorna beatsPerMeasure, subdivisionFactor)
                updateMetronomeConfig(); 
                
                // 3. Configurazione Accelerazione 
                updateAccelerationVars();
                // FIX: Il contatore deve essere resettato a 0 per evitare l'accelerazione immediata.
                // Traccia le misure *completate* dall'ultima accelerazione.
                measuresCounter = 0; 
                
                // 4. Configurazione Timer
                isTimerActive = document.getElementById('timerToggle').checked;
                if (isTimerActive) {
                    // La durata totale è già stata impostata da updateTimerControlsVisibility/updateTimerDuration
                    if (timerDurationSeconds <= 0) {
                        alert("Il timer deve essere impostato per essere attivato.");
                        document.getElementById('timerToggle').checked = false;
                        document.getElementById('timerControls').classList.add('hidden');
                        document.getElementById('timerDisplay').classList.add('hidden');
                        return;
                    }
                    
                    // Reset e Avvio del Conto alla Rovescia
                    timerStartTime = Date.now(); 
                    isRunning = true; 
                    updateTimerDuration(); // Avvia l'intervallo
                }

                // 5. Avvio Metronomo Core
                isRunning = true;
                currentSubBeat = 0;
                nextBeatTime = audioContext.currentTime + 0.05; 
                
                const workerContent = `
                    let timerID = null;
                    let interval = 25.0; // ms
                    self.onmessage = function(e) {
                        if (e.data == "start") {
                            timerID = setInterval(() => { postMessage("tick"); }, interval);
                        } else if (e.data == "stop") {
                            clearInterval(timerID);
                            timerID = null;
                        } else if (e.data.interval) {
                            interval = e.data.interval;
                            if (timerID) { 
                                clearInterval(timerID);
                                timerID = setInterval(() => { postMessage("tick"); }, interval);
                            }
                        }
                    };
                `;
                const workerBlob = new Blob([workerContent], { type: 'application/javascript' });
                const workerURL = URL.createObjectURL(workerBlob);
                
                timerWorker = new Worker(workerURL);
                timerWorker.onmessage = function(e) {
                    if (e.data === "tick") {
                        scheduler();
                    }
                };
                
                timerWorker.postMessage("start");
                timerWorker.postMessage({ "interval": LOOKAHEAD });
                
                startButton.textContent = 'FERMA';
                startButton.classList.replace('bg-green-500', 'bg-red-500');
                startButton.classList.replace('shadow-green-500/50', 'shadow-red-500/50');
                
            } else {
                // FERMATA
                isRunning = false;
                
                if (timerWorker) {
                    timerWorker.postMessage("stop");
                    timerWorker.terminate();
                    timerWorker = null;
                }
                
                if (timerCountdownInterval) {
                    clearInterval(timerCountdownInterval);
                    timerCountdownInterval = null;
                }
                document.getElementById('timerDisplay').classList.add('hidden');
                timerStartTime = 0; // Reset timer start time
                
                startButton.textContent = 'INIZIA';
                startButton.classList.replace('bg-red-500', 'bg-green-500');
                startButton.classList.replace('shadow-red-500/50', 'shadow-green-500/50');
                
                document.querySelectorAll('.beat-dot').forEach(dot => {
                    dot.classList.remove('accent', 'strong');
                });
                
                document.getElementById('statusMessage').classList.add('hidden');
                tapTimes = []; 
            }
        }
        
        // ====================================================
        // FUNZIONI GLOBALI (Logica UI/Configurazione)
        // ====================================================
        
        // FUNZIONE MODIFICATA PER GESTIRE IL RAGGRUPPAMENTO SU DUE RIGHE (NUOVA LOGICA)
        function setupBeatIndicators() {
            const beatIndicatorsDiv = document.getElementById('beatIndicators');
            if (!beatIndicatorsDiv) return;
            beatIndicatorsDiv.innerHTML = '';
            
            // --- Logica di dimensionamento dinamico ---
            const baseSize = 64; // Dimensione desiderata per 4/4
            const sizeForWrap = 60; // Dimensione ridotta per le misure complesse
            let dotSize = (beatsPerMeasure <= 4) ? baseSize : sizeForWrap; 
            
            // --- Logica di raggruppamento per le misure complesse (NUOVA) ---
            const customGroupings = {
                '7': [4, 3],  // Esempio 7/4: 4 battiti sopra, 3 sotto
                '8': [4, 4],  // Esempio 8/4: 4 battiti sopra, 4 sotto
                '9': [4, 5],  // Esempio 9/4 o 9/8: 4 battiti sopra, 5 sotto
                '12': [6, 6] // Esempio 12/4 o 12/8: 6 battiti sopra, 6 sotto
            };
            
            const grouping = customGroupings[String(beatsPerMeasure)];

            let currentBeatIndex = 0;

            // Funzione helper per creare i pallini
            function createDots(count, startIndex) {
                for (let i = 0; i < count; i++) {
                    const dot = document.createElement('div');
                    dot.classList.add('beat-dot'); 
                    dot.id = `dot-${startIndex + i}`; // ID sequenziale
                    
                    // Imposta la dimensione dinamica 
                    dot.style.width = `${dotSize}px`; 
                    dot.style.height = `${dotSize}px`; 
                    
                    beatIndicatorsDiv.appendChild(dot);
                }
            }

            if (grouping) {
                // Raggruppamento personalizzato su due righe
                
                // 1. Gruppo 1
                createDots(grouping[0], 0);
                currentBeatIndex += grouping[0];

                // 2. Separatore di riga (Forza l'avvolgimento su una nuova riga)
                const lineBreak = document.createElement('div');
                // La spaziatura verticale è garantita da 'gap: 1rem;' del contenitore.
                lineBreak.classList.add('w-full', 'h-0'); 
                beatIndicatorsDiv.appendChild(lineBreak);

                // 3. Gruppo 2
                createDots(grouping[1], currentBeatIndex);
                
            } else {
                // Nessun raggruppamento personalizzato (per 2, 3, 4, 5, 6, ecc. non specificati)
                createDots(beatsPerMeasure, 0);
            }
        }
        
        function updateMetronomeConfig() {
            const timeSignatureSelect = document.getElementById('timeSignatureSelect'); 
            const subdivisionSelect = document.getElementById('subdivisionSelect');
            
            if (timeSignatureSelect) beatsPerMeasure = parseInt(timeSignatureSelect.value) || 4;
            if (subdivisionSelect) subdivisionFactor = parseInt(subdivisionSelect.value) || 1;
            
            totalSubBeats = beatsPerMeasure * subdivisionFactor;
            
            setupBeatIndicators(); 
            
            // NUOVO: Aggiorna la visibilità dei controlli suddivisione
            updateSubdivisionVisibility(); 
        }

        /**
         * Gestisce la visibilità dello switch mute e dello slider volume suddivisioni.
         * Sono nascosti quando la suddivisione è 'Semiminima' (valore 1).
         */
        function updateSubdivisionVisibility() {
            const subdivisionSelect = document.getElementById('subdivisionSelect');
            const muteContainer = document.getElementById('muteSubdivisionsContainer');
            const volumeControls = document.getElementById('subdivisionVolumeControls');
            const muteToggle = document.getElementById('muteSubdivisionsToggle'); 
            
            if (!subdivisionSelect || !muteContainer || !volumeControls || !muteToggle) return;

            // Il valore '1' corrisponde a Semiminima (♩), dove le suddivisioni sono i battiti principali.
            const isSubdivisionFactorOne = subdivisionSelect.value === '1';

            if (isSubdivisionFactorOne) {
                muteContainer.classList.add('hidden');
                volumeControls.classList.add('hidden');
                // Sincronizza lo stato interno per coerenza quando è nascosto
                isSubdivisionMuted = true;
            } else {
                muteContainer.classList.remove('hidden');
                
                // Logica di visibilità secondaria: nasconde lo slider volume se lo switch mute è attivo
                if (muteToggle.checked) {
                     volumeControls.classList.add('hidden');
                } else {
                     volumeControls.classList.remove('hidden');
                }
            }
        }


        /**
         * Aggiorna le variabili di accelerazione e viene chiamata su ogni modifica 
         * (input, stepper, toggle).
         */
        function updateAccelerationVars() {
            const measuresInput = document.getElementById('measuresForAcceleration');
            const increaseInput = document.getElementById('bpmIncrease');

            // LEGGE i valori correnti dall'input (anche se non ancora clammati dal blur)
            const measuresVal = parseInt(measuresInput.value) || 1;
            const increaseVal = parseInt(increaseInput.value) || 1;
            
            // AGGIORNA LE VARIABILI GLOBALI USATE NELLO SCHEDULER
            isAccelerationActive = document.getElementById('progressiveAccelerationToggle').checked;
            measuresToAccelerate = measuresVal;
            bpmIncreaseAmount = increaseVal;

            // Aggiorna i valori validi (backup)
            lastValidValues.measuresForAcceleration = measuresVal;
            lastValidValues.bpmIncrease = increaseVal;
        }

        function getTempoName(bpm) {
            let tempoEntry = tempoMap.find(entry => bpm >= entry.minBPM && bpm <= entry.maxBPM);
            if (tempoEntry) {
                const name = tempoEntry.name;
                const minBPM = tempoEntry.minBPM;
                const maxBPM = tempoEntry.maxBPM;
                const formattedName = name.charAt(0) + name.slice(1).toLowerCase();
                return `${formattedName} (${minBPM}-${maxBPM})`;
            }
            return "Tempo Sconosciuto";
        }
        
        /**
         * Aggiorna lo stato interno (initialBPM) e gli elementi di feedback (Slider, Testo Tempo, INPUT BPM).
         * @param {number} bpmValue - Il nuovo valore BPM.
         * @param {boolean} [isTextualInput=false] - Se la chiamata proviene dall'input testuale (in digitazione).
         */
        function updateBPMDisplay(bpmValue, isTextualInput = false) {
            const bpmInput = document.getElementById('bpm'); // Riferimento all'input principale
            const bpmSlider = document.getElementById('bpmSlider');
            const tempoIndicatorText = document.getElementById('tempoIndicatorText');
            const newBPM = parseInt(bpmValue);
            
            if (!bpmInput || !bpmSlider || !tempoIndicatorText || isNaN(newBPM)) return;
            
            // 1. Clamping per lo stato interno e feedback (slider/tempo)
            const minBPM = 40;
            const maxBPM = 300;
            let clampedBPM = newBPM;
            if (clampedBPM < minBPM) clampedBPM = minBPM; 
            if (clampedBPM > maxBPM) clampedBPM = maxBPM;
            
            initialBPM = clampedBPM; // Aggiorna lo stato interno con il valore CLAMPED
            
            // 2. Aggiornamento UI di Feedback (usa sempre il valore CLAMPED)
            bpmSlider.value = clampedBPM; 
            tempoIndicatorText.textContent = getTempoName(clampedBPM);

            // 3. Aggiornamento UI INPUT TESTUALE
            if (!isTextualInput) {
                // Se la chiamata non proviene dall'input testuale (es. Slider o Stepper/Accelerazione), 
                // aggiorna il campo testo con il valore CLAMPED.
                bpmInput.value = clampedBPM; 
            }
            // Se isTextualInput è true (utente sta digitando), NON sovrascrivere l'input 
            // per evitare che venga clammato a 40 mentre l'utente digita '1', '2', ecc.
        }
        
        /**
         * Funzione di clamping finale chiamata al 'blur' o 'Enter' per BPM.
         */
        function clampAndSetFinalBPM() {
            const bpmInput = document.getElementById('bpm');
            const min = parseInt(bpmInput.min) || 40;
            const max = parseInt(bpmInput.max) || 300;
            let rawValue = bpmInput.value.trim();
            let finalBPM;

            if (rawValue === '') {
                finalBPM = initialBPM || min; 
            } else {
                let tempBPM = parseInt(rawValue);
                if (isNaN(tempBPM)) {
                    finalBPM = initialBPM || min;
                } else {
                    finalBPM = tempBPM;
                    // CLAMPING FINALE
                    if (finalBPM < min) { finalBPM = min; } 
                    if (finalBPM > max) { finalBPM = max; }
                }
            }

            // Aggiorna lo stato interno e il feedback UI (slider/tempo text e input)
            // CHIAMATA AGGIORNATA: Non usa isTextualInput, quindi aggiorna il campo BPM (clammato)
            updateBPMDisplay(finalBPM); 
        }

        /**
         * Funzione di clamping finale chiamata al 'blur' o 'Enter' per INPUT NUMERICI.
         * @param {HTMLElement} inputElement - L'elemento input.
         */
        function clampAndSetFinalValue(inputElement) {
            const minAttr = inputElement.getAttribute('min');
            const maxAttr = inputElement.getAttribute('max');
            const id = inputElement.id;

            const min = minAttr !== null && !isNaN(parseInt(minAttr)) ? parseInt(minAttr) : 0; 
            const max = maxAttr !== null && !isNaN(parseInt(maxAttr)) ? parseInt(maxAttr) : Infinity;
            
            let rawValue = inputElement.value.trim();
            let finalValue;

            if (rawValue === '') {
                finalValue = lastValidValues[id] !== undefined ? lastValidValues[id] : min;
            } else {
                let tempVal = parseInt(rawValue);

                if (isNaN(tempVal)) {
                    finalValue = lastValidValues[id] !== undefined ? lastValidValues[id] : min;
                } else {
                    finalValue = tempVal;
                    
                    // CLAMPING
                    if (finalValue < min) { finalValue = min; } 
                    if (finalValue > max) { finalValue = max; }
                }
            }

            // Aggiorna l'input con il valore finale clammato
            inputElement.value = finalValue; 
            // Aggiorna la variabile di stato (backup)
            lastValidValues[id] = finalValue;
            
            // La sincronizzazione in tempo reale avviene nell'evento 'input' per gli input numerici
        }


        // Logica Stepper (pressione prolungata)
        function startPress(elementId, step) {
            changeValue(elementId, step);
            clearPress(); 
            pressTimer = setTimeout(() => {
                pressInterval = setInterval(() => {
                    changeValue(elementId, step);
                }, REPEAT_INTERVAL);
            }, INITIAL_DELAY);
        }

        function clearPress() {
            if (pressTimer) {
                clearTimeout(pressTimer);
                pressTimer = null;
            }
            if (pressInterval) {
                clearInterval(pressInterval);
                pressInterval = null;
            }
        }
        
        /**
         * Gestisce l'incremento/decremento tramite stepper.
         */
        function changeValue(elementId, step) {
            const input = document.getElementById(elementId);
            if (!input) return;

            if (elementId === 'bpm') {

                const min = parseInt(input.min) || 40;
                const max = parseInt(input.max) || 300;
                let newValue = initialBPM + step; 
                
                if (newValue < min) newValue = min;
                if (newValue > max) newValue = max;

                // Lo stepper BPM aggiorna lo stato interno e il campo immediatamente
                // CHIAMATA AGGIORNATA: Non usa isTextualInput, quindi aggiorna il campo BPM (clammato)
                updateBPMDisplay(newValue); 
                return;
            }

            // Per tutti gli altri input numerici
            let currentValue = parseInt(input.value) || lastValidValues[elementId] || 0; 
            let newValue = currentValue + step;

            const minAttr = input.getAttribute('min');
            const maxAttr = input.getAttribute('max');
            const min = minAttr !== null && !isNaN(parseInt(minAttr)) ? parseInt(minAttr) : 0; 
            const max = maxAttr !== null && !isNaN(parseInt(maxAttr)) ? parseInt(maxAttr) : Infinity;

            // Logica di wrapping/clamping per stepper
            if (elementId === 'timerSeconds') {
                if (newValue < min) newValue = 59; 
                if (newValue > max) newValue = 0; 
            } else {
                 if (newValue < min) newValue = min; 
                 if (newValue > max) newValue = max;
            }
            
            input.value = newValue;
            
            // AGGIORNATO: Aggiorna lo stato interno (backup) e le dipendenze in tempo reale
            lastValidValues[elementId] = newValue;

            // Chiamo le funzioni di aggiornamento in tempo reale
            if (elementId.startsWith('timer')) {
                // Se il metronomo è in esecuzione, ricalcola il tempo residuo
                if (isRunning) {
                     updateTimerDuration(); 
                }
            } else if (elementId === 'measuresForAcceleration' || elementId === 'bpmIncrease') {
                // Aggiorna i parametri di accelerazione in tempo reale
                updateAccelerationVars();
            }
        }
        
        function updateAccelerationControlsVisibility() {
            const progressiveAccelerationToggle = document.getElementById('progressiveAccelerationToggle');
            const accelerationControls = document.getElementById('accelerationControls');
            if (!progressiveAccelerationToggle || !accelerationControls) return;
            
            if (progressiveAccelerationToggle.checked) {
                accelerationControls.classList.remove('hidden');
            } else {
                accelerationControls.classList.add('hidden');
            }

            // Aggiorna le variabili globali in base allo stato del toggle
            updateAccelerationVars(); 
        }
        
        function updateTimerControlsVisibility() {
            const timerToggle = document.getElementById('timerToggle'); 
            const timerControls = document.getElementById('timerControls'); 
            const timerDisplay = document.getElementById('timerDisplay'); 

            if (timerToggle.checked) {
                timerControls.classList.remove('hidden');
                timerDisplay.classList.remove('hidden'); // MOSTRA IL DISPLAY QUANDO IL TOGGLE È ON
            } else {
                timerControls.classList.add('hidden');
                timerDisplay.classList.add('hidden'); // NASCONDE IL DISPLAY
            }

            // Aggiorna le variabili globali e il display (anche se metronomo è fermo)
            updateTimerDuration();
        }
        
        // ====================================================
        // INIZIALIZZAZIONE EVENTI (DOM Content Loaded)
        // ====================================================

        document.addEventListener('DOMContentLoaded', () => {
            const bpmInput = document.getElementById('bpm'); 
            const bpmSlider = document.getElementById('bpmSlider');
            const startButton = document.getElementById('startButton');
            const tapTempoButton = document.getElementById('tapTempoButton'); 
            const progressiveAccelerationToggle = document.getElementById('progressiveAccelerationToggle');
            const timerToggle = document.getElementById('timerToggle'); 
            const muteSubdivisionsToggle = document.getElementById('muteSubdivisionsToggle'); 
            const timeSignatureSelect = document.getElementById('timeSignatureSelect'); 
            const subdivisionSelect = document.getElementById('subdivisionSelect');
            
            // Riferimento allo slider del volume suddivisioni
            const subdivisionVolumeSlider = document.getElementById('subdivisionVolumeSlider'); 
            
            const timerMinutes = document.getElementById('timerMinutes');
            const timerSeconds = document.getElementById('timerSeconds');
            const measuresForAcceleration = document.getElementById('measuresForAcceleration');
            const bpmIncrease = document.getElementById('bpmIncrease');

            // 1. Inizializzazione Configurazione UI e LastValidValues
            
            // Inizializza LastValidValues dai valori di default del DOM
            lastValidValues = {
                timerMinutes: parseInt(timerMinutes.value) || 1,
                timerSeconds: parseInt(timerSeconds.value) || 0,
                measuresForAcceleration: parseInt(measuresForAcceleration.value) || 1,
                bpmIncrease: parseInt(bpmIncrease.value) || 1
            };
            
            initialBPM = parseInt(bpmInput.value) || 120;
            // CHIAMATA AGGIORNATA: inizializza l'interfaccia
            updateBPMDisplay(initialBPM); 
            
            // Aggiorna la configurazione (che ora include la visibilità suddivisioni)
            updateMetronomeConfig(); 
            
            // Mostra/Nasconde i controlli e aggiorna lo stato iniziale (IMPORTANTE)
            updateAccelerationControlsVisibility();
            updateTimerControlsVisibility();
            
            // Sincronizza lo stato iniziale del volume e del mute
            subdivisionGain = parseFloat(subdivisionVolumeSlider.value) || 0.5; 
            isSubdivisionMuted = muteSubdivisionsToggle.checked; 
            
            // La visibilità iniziale dei controlli è gestita da updateMetronomeConfig() che è chiamata sopra.


            // 2. Listener per START/STOP e TAP TEMPO
            startButton.addEventListener('click', startStopMetronome);
            tapTempoButton.addEventListener('click', handleTapTempo); 

            // 3. Listener per la visibilità condizionale e CONFIGURAZIONE DINAMICA
            
            // La visibilità è ora gestita da queste due funzioni
            timerToggle.addEventListener('change', updateTimerControlsVisibility);
            progressiveAccelerationToggle.addEventListener('change', updateAccelerationControlsVisibility);
            
            // Listener per mutare le suddivisioni (AGGIORNATO)
            muteSubdivisionsToggle.addEventListener('change', () => {
                isSubdivisionMuted = muteSubdivisionsToggle.checked;
                // Richiama la funzione di visibilità per nascondere/mostrare lo slider volume
                updateSubdivisionVisibility(); 
            });
            
            // Listener per il volume delle suddivisioni
            subdivisionVolumeSlider.addEventListener('input', (e) => {
                subdivisionGain = parseFloat(e.target.value);
            });


            timeSignatureSelect.addEventListener('change', updateMetronomeConfig);
            subdivisionSelect.addEventListener('change', updateMetronomeConfig);
            
            
            // 4. Gestione input BPM e Slider
            const handleBPMInput = (event) => {
                let rawValue = event.target.value;

                if (event.target.id === 'bpmSlider') {
                    // SLIDER: sempre valido, aggiorna tutto immediatamente
                    let sliderBPM = parseInt(rawValue);
                    // CHIAMATA AGGIORNATA: aggiorna l'input text con il valore clammato
                    updateBPMDisplay(sliderBPM);
                    return; 
                }

                // INPUT TESTUALE BPM: gestisce la digitazione libera
                let tempBPM = parseInt(rawValue);
                if (!isNaN(tempBPM)) {
                    // CHIAMATA AGGIORNATA: passa true. Aggiorna stato interno e feedback (slider/tempo), ma NON il campo di input testuale
                    updateBPMDisplay(tempBPM, true); 
                }
                
                // NOTA: Se rawValue è vuoto o NaN, non facciamo nulla. Il clamping finale avverrà in clampAndSetFinalBPM (su blur/enter)
            };
            
            // Eventi per validazione e clamping finale BPM
            bpmInput.addEventListener('input', handleBPMInput);
            bpmSlider.addEventListener('input', handleBPMInput);
            
            // Logica di clamping e scrittura finale del valore al BLUR o ENTER (BPM)
            bpmInput.addEventListener('blur', clampAndSetFinalBPM); 
            bpmInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    clampAndSetFinalBPM(); // Applica i cambiamenti
                    bpmInput.blur(); // Rimuovi il focus
                }
            });
            
            // 5. Gestione Input Numerici Secondari (Timer/Accelerazione)
            const numericInputs = document.querySelectorAll('.input-to-validate');
            
            numericInputs.forEach(input => {
                const id = input.id;

                // L'evento 'input' serve a SINCRONIZZARE il metronomo avviato in tempo reale
                input.addEventListener('input', (e) => {
                    const rawValue = e.target.value.trim();
                    let tempVal = parseInt(rawValue);
                    
                    if (!isNaN(tempVal)) {
                        // Aggiorna lo stato interno con l'input corrente
                        lastValidValues[id] = tempVal; 
                    }
                    
                    // Sincronizza il metronomo se è in esecuzione
                    if (isRunning) {
                         if (id.startsWith('timer')) {
                            updateTimerDuration();
                        } else if (id === 'measuresForAcceleration' || id === 'bpmIncrease') {
                            updateAccelerationVars();
                        }
                    }
                });

                // BLUR: Clamping e aggiornamento stato finale
                input.addEventListener('blur', () => {
                    clampAndSetFinalValue(input);
                    
                    // Rilancia la configurazione finale dopo il clamping
                    if (id.startsWith('timer')) {
                        updateTimerDuration();
                    } else if (id === 'measuresForAcceleration' || id === 'bpmIncrease') {
                        updateAccelerationVars();
                    }
                });

                // ENTER: Clamping e rimozione focus
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        clampAndSetFinalValue(input);
                        input.blur();
                    }
                });
            });


            // 6. Listener per Pressione Prolungata di TUTTI gli Stepper
            const pressButtons = [
                { id: 'bpmDownButton', target: 'bpm', step: -1 },
                { id: 'bpmUpButton', target: 'bpm', step: 1 },
                { id: 'timerMinutesDown', target: 'timerMinutes', step: -1 },
                { id: 'timerMinutesUp', target: 'timerMinutes', step: 1 },
                { id: 'timerSecondsDown', target: 'timerSeconds', step: -1 },
                { id: 'timerSecondsUp', target: 'timerSeconds', step: 1 },
                { id: 'measuresForAccelerationDown', target: 'measuresForAcceleration', step: -1 },
                { id: 'measuresForAccelerationUp', target: 'measuresForAcceleration', step: 1 },
                { id: 'bpmIncreaseDown', target: 'bpmIncrease', step: -1 },
                { id: 'bpmIncreaseUp', target: 'bpmIncrease', step: 1 },
            ];
            
            const releaseEvents = ['mouseup', 'touchend', 'mouseleave', 'touchcancel'];

            pressButtons.forEach(btn => {
                const element = document.getElementById(btn.id);
                if (element) {
                    element.addEventListener('mousedown', (e) => {
                        if (e.button === 0) startPress(btn.target, btn.step);
                    });
                    
                    element.addEventListener('touchstart', (e) => {
                        e.preventDefault(); 
                        startPress(btn.target, btn.step);
                    }, { passive: false });

                    releaseEvents.forEach(event => {
                        element.addEventListener(event, clearPress);
                    });
                }
            });
            
            // PWA: Registra il service worker (omesso per brevità)
        });

    </script>
</body>
</html>
